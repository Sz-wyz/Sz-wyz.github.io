{"meta":{"title":"Szwyz's Blog","subtitle":"蚍蜉撼树","description":"","author":"Szwyz","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-28T03:20:55.000Z","updated":"2020-06-28T03:25:10.105Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C#学习笔记（未完）","slug":"C#学习笔记（未完）","date":"2020-07-01T09:47:31.334Z","updated":"2020-07-01T09:46:54.058Z","comments":true,"path":"2020/07/01/C#学习笔记（未完）/","link":"","permalink":"http://yoursite.com/2020/07/01/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/","excerpt":"","text":"C# 编译 C#编译器是把.cs结尾的源码文件编译成Assembly Assembly是.NET Core里的包装和部署的单元 Assembly可以是应用程序，也可以是库 .exe .dll Null附加课程 可空值 类型 可空值类型是System.Nullable&lt;T&gt;这个struct的实例 可空值类型除了可以正确的表示其底层数据类型的范围，还可以表示null 例如 bool类型有True和False 而 Nullable&lt;bool&gt;有True、False和null 123456static void Main(string[] args) &#123; string str &#x3D; &quot;dsafdsafdsfsd&quot;; int? indexOfM &#x3D; null; &#x2F;&#x2F; 可空类型 Nullable&lt;int&gt; indexOFM &#x3D; null; &#x2F;&#x2F; 相当于这个 &#125; Null和空，空白string string name = “Nick”; string name = null; string name = “”; string name = “ “; 判断Null和空，空白string if(name==null){…} if(string.isNullOrEmpty(name)){…} if(string.isNullOrWhiteSpace(name)){…} Nullable&lt;T&gt;的常用属性和方法 .HasValue .Value // 底层值类型的值（不常用） .GetValueOrDefault() // 底层值类型的值或该类型的默认值 .GetValueOrDefault(默认值) // 底层值类型的值或指定的默认值 Nullable&lt;T&gt;转换 T-&gt;Nullable&lt;T&gt;隐式转换 Nullable&lt;T&gt;-&gt;T显式转换 123456789101112131415static void Main(string[] args) &#123; &#123; int i &#x3D; 3; int? j &#x3D; i; &#x2F;&#x2F; 隐式转换 Console.WriteLine(j); &#125; &#123; int? i &#x3D; 3; int j &#x3D; (int)i; &#x2F;&#x2F; 显式转换 Console.WriteLine(j); &#125; &#125; 在C#中创建类型 123class YourClassName&#123;&#125; 在class关键字之前：类特性（Attribute）和类修饰符。非嵌套的类修饰符有：public、internal、abstract、sealed、unsafe和partial 在{}内：类成员（方法、属性、索引器、事件、字段、构造器、重载运算符、嵌套类型和终结器） 字段是类或者结构体中的变量成员 12345class Octopus&#123; string name; public int Age &#x3D; 10;&#125; 字段可以以下修饰符进行修饰： 静态修饰符：static 访问权限修饰符：public internal private protected 继承修饰符：new 不安全代码修饰符：unsafe 只读修饰符：readonly //防止字段在构造后进行变更 线程访问修饰符：volatile 方法 方法通过指定的输出类型将输出数据返回给调用者，此外，方法还可以通过ref/out参数向调用者返回输出数据。 方法的签名在一个类中必须是唯一的。方法的签名由它的名字和一定顺序的参数类型（但不包含参数名和返回值类型）组成。 注意：方法的返回值类型和params修饰符不属于方法签名的一部分 12345void Foo(int x)&#123;...&#125;float Foo(int x)&#123;...&#125; &#x2F;&#x2F; Compile-time errorvoid Goo(int[] x)&#123;...&#125;void Goo(params int[] x)&#123;...&#125; &#x2F;&#x2F; Compile-time error 方法可以用一下修饰符修饰： 静态修饰符：static 访问权限修饰符：public internal private protected 继承修饰符：new virtual abstract override sealed 部分方法修饰符：partial 非托管代码修饰符：unsafe extern 异步代码修饰符：async expression-bodied方法（C#6) 1234567int Foo(int x) &#123; return x * 2; &#125; &#x2F;&#x2F;仅由一个表达式构成的方法&#x2F;&#x2F;可用双箭头来却带花括号和returnint Foo(int x) &#x3D;&gt; x*2;&#x2F;&#x2F;void返回类型也可支持void Foo(int x) &#x3D;&gt; Console.WriteLine(x); 按值传递和按引用传递 参数按值传递还是按引用传递也是方法签名的一部分。例如Foo(int)和Foo(ref int)或者Foo(out int)可以出现在一个类中。但是Foo(ref int)和Foo(out int)不能同时出现在一个类中。 123void Foo(int x)&#123;...&#125;void Foo(ref int x)&#123;...&#125; &#x2F;&#x2F; OK so farvoid Foo(out int x)&#123;...&#125; &#x2F;&#x2F; Compile-time error 局部方法（C#7） C#7开始允许一个方法中定义另外一个方法。局部方法不能用static修饰 123456void WriteCubes()&#123; Console.WriteLine(Cube(3)); int Cube(int value) &#x3D;&gt; value*value*value;&#125; 实例构造器（构造函数） 12345678910public class Panda&#123; string name; public Panda(string n) &#x2F;&#x2F; 构造器名和返回值只能和封装类的类型相同 &#123; name &#x3D; n; &#125;&#125;Panda p &#x3D; new Panda(&quot;petey&quot;); 实例构造器支持一下的修饰符： 访问权限修饰符：public internal private protected 非托管代码修饰符：unsafe extern 也可这么写：public Panda(string n) =&gt; name = n;构造器的重载：为了避免代码重复，构造器可以用this关键字来调用另一个构造器 1234567891011using System;public class Wine&#123; public decimal Price; public int Year; public Wine(decimal price)&#123; Price &#x3D; price;&#125; public Wine(decimal price,int year):this (price)&#123;Year &#x3D; year;&#125; &#x2F;&#x2F; 还可以向另一个构造器传递表达式 public Wine(decimal price,DateTime year):this (price,year.Year)&#123;&#125;&#125; 非公有构造器 ：在C#中，构造器不添加修饰符，则默认是private类型的。非共有构造器通常用在单例设计中 12345public class Class1&#123; Class1()&#123;&#125; &#x2F;&#x2F; private constructro public static Class1 Create(...)&#123;...&#125;&#125; 解构器（析构函数） 解析方法的名字必须是Deconstruct,并且拥有一个或多个out参数。 123456789101112131415class Rectangle&#123; public readonly float Width, Height; public Rectangle(float width, float height) &#123; Width &#x3D; width; Height &#x3D; height; &#125; public void Deconstruct(out float width, out float height) &#123; width &#x3D; Width; height &#x3D; Height; &#125;&#125; 如果需要调用解构器，则需使用如下的语法： 1234567var rect &#x3D; new Rectangle(3, 4);(float width, float height) &#x3D; rect; &#x2F;&#x2F; DeconstructionSystem.Console.WriteLine(width + &quot; &quot; + height);&#x2F;&#x2F; 相当于float width,height;rec.Deconstruct(out width,out height);","categories":[],"tags":[]},{"title":"设计模式（未完）","slug":"设计模式（未完）","date":"2020-06-29T03:58:50.845Z","updated":"2020-06-29T03:57:42.841Z","comments":true,"path":"2020/06/29/设计模式（未完）/","link":"","permalink":"http://yoursite.com/2020/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/","excerpt":"","text":"设计模式 单例模式 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。类的构造方法一定不能是public的 ，只能是private。这个实例是当前类的类成员变量，静态变量 12345678910111213public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton; //唯一类变量 private Singleton()&#123;&#125; //构造方法私有 public static Singleton getInstance()&#123; return null; &#125;&#125; 单例模式的实例化时机分为饿汉式和懒汉式 1234567891011121314151617181920212223242526272829303132//饿汉式：在类加载的时候就进行实例化public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton = new Singleton(); //实例化 private Singleton()&#123;&#125; //构造方法私有 public static Singleton getInstance()&#123; return singleton;//返回singleton &#125;&#125;//懒汉式：在第一次使用的时候进行实例化public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton; private Singleton()&#123;&#125; //构造方法私有 public synchronized static Singleton getInstance()&#123; //加锁 if(singleton == null) singleton = new Singleton(); return singleton;//在第一次调用getInstance()方法时才进行实例化 &#125;&#125;","categories":[],"tags":[]},{"title":"vscode配置","slug":"vscode配置","date":"2020-06-28T12:23:48.182Z","updated":"2020-06-30T04:40:18.010Z","comments":true,"path":"2020/06/28/vscode配置/","link":"","permalink":"http://yoursite.com/2020/06/28/vscode%E9%85%8D%E7%BD%AE/","excerpt":"","text":"VSCode配置 更换主题 ctrl+shift+p 后输入Preferences Color Theme进行选择 图标主题 ctrl+shift+p 后输入Preferences File Icon Theme进行选择 生成构造函数 ctor 字号等设置 ctrl+， 自动保存 设置中 save搜索 在Auto Save选项中选择afterDelay 主命令框 F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下 Backspace 会进入到 Ctrl+P 模式 在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式 在 Ctrl+P 窗口下还可以: 直接输入文件名，跳转到文件 ? 列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol，也可以 Ctrl+T 常用快捷键 编辑器与窗口管理 打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 同时打开多个编辑器（查看多个文件） 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 切出一个新的编辑器（最多 3 个） Ctrl+\\，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名 左中右 3 个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+3 3 个编辑器之间循环切换 Ctrl+ 编辑器换位置， Ctrl+k然后按 Left或 Right 代码编辑 格式调整 代码行缩进 Ctrl+[ 、 Ctrl+] Ctrl+C 、 Ctrl+V 复制或剪切当前行/当前选中内容 代码格式化： Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code 上下移动一行： Alt+Up 或 Alt+Down 向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 在当前行下边插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 光标相关 移动到行首： Home 移动到行尾： End 移动到文件结尾： Ctrl+End 移动到文件开头： Ctrl+Home 移动到定义处： F12 定义处缩略图：只看一眼而不跳转过去 Alt+F12 移动到后半个括号： Ctrl+Shift+] 选择从光标到行尾： Shift+End 选择从行首到光标处： Shift+Home 删除光标右侧的所有字： Ctrl+Delete 扩展/缩小选取范围： Shift+Alt+Left 和 Shift+Alt+Right 多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 (在 sublime 中是删除当前行，后面自定义快键键中，设置与 Ctrl+Shift+K 互换了) 回退上一个光标操作： Ctrl+U 重构代码 找到所有的引用： Shift+F12 同时修改本文件中所有匹配的： Ctrl+F12 重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了 跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转 查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose 查找替换 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F 显示相关 全屏：F11 zoomIn/zoomOut：Ctrl +/- 侧边栏显/隐：Ctrl+B 显示资源管理器 Ctrl+Shift+E 显示搜索 Ctrl+Shift+F 显示 Git Ctrl+Shift+G 显示 Debug Ctrl+Shift+D 显示 Output Ctrl+Shift+U","categories":[],"tags":[]},{"title":"Java学习路线","slug":"Java学习路线","date":"2020-06-28T03:28:13.038Z","updated":"2020-06-29T06:30:30.403Z","comments":true,"path":"2020/06/28/Java学习路线/","link":"","permalink":"http://yoursite.com/2020/06/28/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"title：Java学习路线 测试字段","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-28T01:22:21.684Z","updated":"2020-06-28T01:22:21.684Z","comments":true,"path":"2020/06/28/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}