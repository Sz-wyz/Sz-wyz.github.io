{"meta":{"title":"Szwyz's Blog","subtitle":"蚍蜉撼树","description":"","author":"Szwyz","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-28T03:20:55.000Z","updated":"2020-06-28T03:25:10.105Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C#学习笔记（未完）","slug":"C#学习笔记（未完）","date":"2020-07-01T09:47:31.334Z","updated":"2020-07-02T14:36:19.224Z","comments":true,"path":"2020/07/01/C#学习笔记（未完）/","link":"","permalink":"http://yoursite.com/2020/07/01/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/","excerpt":"","text":"C# 编译 C#编译器是把.cs结尾的源码文件编译成Assembly Assembly是.NET Core里的包装和部署的单元 Assembly可以是应用程序，也可以是库 .exe .dll Null附加课程 可空值 类型 可空值类型是System.Nullable&lt;T&gt;这个struct的实例 可空值类型除了可以正确的表示其底层数据类型的范围，还可以表示null 例如 bool类型有True和False 而 Nullable&lt;bool&gt;有True、False和null 123456static void Main(string[] args) &#123; string str &#x3D; &quot;dsafdsafdsfsd&quot;; int? indexOfM &#x3D; null; &#x2F;&#x2F; 可空类型 Nullable&lt;int&gt; indexOFM &#x3D; null; &#x2F;&#x2F; 相当于这个 &#125; Null和空，空白string string name = “Nick”; string name = null; string name = “”; string name = “ “; 判断Null和空，空白string if(name==null){…} if(string.isNullOrEmpty(name)){…} if(string.isNullOrWhiteSpace(name)){…} Nullable&lt;T&gt;的常用属性和方法 .HasValue .Value // 底层值类型的值（不常用） .GetValueOrDefault() // 底层值类型的值或该类型的默认值 .GetValueOrDefault(默认值) // 底层值类型的值或指定的默认值 Nullable&lt;T&gt;转换 T-&gt;Nullable&lt;T&gt;隐式转换 Nullable&lt;T&gt;-&gt;T显式转换 123456789101112131415static void Main(string[] args) &#123; &#123; int i &#x3D; 3; int? j &#x3D; i; &#x2F;&#x2F; 隐式转换 Console.WriteLine(j); &#125; &#123; int? i &#x3D; 3; int j &#x3D; (int)i; &#x2F;&#x2F; 显式转换 Console.WriteLine(j); &#125; &#125; 在C#中创建类型 123class YourClassName&#123;&#125; 在class关键字之前：类特性（Attribute）和类修饰符。非嵌套的类修饰符有：public、internal、abstract、sealed、unsafe和partial 在{}内：类成员（方法、属性、索引器、事件、字段、构造器、重载运算符、嵌套类型和终结器） 字段是类或者结构体中的变量成员 12345class Octopus&#123; string name; public int Age &#x3D; 10;&#125; 字段可以以下修饰符进行修饰： 静态修饰符：static 访问权限修饰符：public internal private protected 继承修饰符：new 不安全代码修饰符：unsafe 只读修饰符：readonly //防止字段在构造后进行变更 线程访问修饰符：volatile 方法 方法通过指定的输出类型将输出数据返回给调用者，此外，方法还可以通过ref/out参数向调用者返回输出数据。 方法的签名在一个类中必须是唯一的。方法的签名由它的名字和一定顺序的参数类型（但不包含参数名和返回值类型）组成。 注意：方法的返回值类型和params修饰符不属于方法签名的一部分 12345void Foo(int x)&#123;...&#125;float Foo(int x)&#123;...&#125; &#x2F;&#x2F; Compile-time errorvoid Goo(int[] x)&#123;...&#125;void Goo(params int[] x)&#123;...&#125; &#x2F;&#x2F; Compile-time error 方法可以用一下修饰符修饰： 静态修饰符：static 访问权限修饰符：public internal private protected 继承修饰符：new virtual abstract override sealed 部分方法修饰符：partial 非托管代码修饰符：unsafe extern 异步代码修饰符：async expression-bodied方法（C#6) 1234567int Foo(int x) &#123; return x * 2; &#125; &#x2F;&#x2F;仅由一个表达式构成的方法&#x2F;&#x2F;可用双箭头来却带花括号和returnint Foo(int x) &#x3D;&gt; x*2;&#x2F;&#x2F;void返回类型也可支持void Foo(int x) &#x3D;&gt; Console.WriteLine(x); 按值传递和按引用传递 参数按值传递还是按引用传递也是方法签名的一部分。例如Foo(int)和Foo(ref int)或者Foo(out int)可以出现在一个类中。但是Foo(ref int)和Foo(out int)不能同时出现在一个类中。 123void Foo(int x)&#123;...&#125;void Foo(ref int x)&#123;...&#125; &#x2F;&#x2F; OK so farvoid Foo(out int x)&#123;...&#125; &#x2F;&#x2F; Compile-time error 局部方法（C#7） C#7开始允许一个方法中定义另外一个方法。局部方法不能用static修饰 123456void WriteCubes()&#123; Console.WriteLine(Cube(3)); int Cube(int value) &#x3D;&gt; value*value*value;&#125; 实例构造器（构造函数） 12345678910public class Panda&#123; string name; public Panda(string n) &#x2F;&#x2F; 构造器名和返回值只能和封装类的类型相同 &#123; name &#x3D; n; &#125;&#125;Panda p &#x3D; new Panda(&quot;petey&quot;); 实例构造器支持一下的修饰符： 访问权限修饰符：public internal private protected 非托管代码修饰符：unsafe extern 也可这么写：public Panda(string n) =&gt; name = n;构造器的重载：为了避免代码重复，构造器可以用this关键字来调用另一个构造器 1234567891011using System;public class Wine&#123; public decimal Price; public int Year; public Wine(decimal price)&#123; Price &#x3D; price;&#125; public Wine(decimal price,int year):this (price)&#123;Year &#x3D; year;&#125; &#x2F;&#x2F; 还可以向另一个构造器传递表达式 public Wine(decimal price,DateTime year):this (price,year.Year)&#123;&#125;&#125; 非公有构造器 ：在C#中，构造器不添加修饰符，则默认是private类型的。非共有构造器通常用在单例设计中 12345public class Class1&#123; Class1()&#123;&#125; &#x2F;&#x2F; private constructro public static Class1 Create(...)&#123;...&#125;&#125; 解构器（析构函数） 解析方法的名字必须是Deconstruct,并且拥有一个或多个out参数。 123456789101112131415class Rectangle&#123; public readonly float Width, Height; public Rectangle(float width, float height) &#123; Width &#x3D; width; Height &#x3D; height; &#125; public void Deconstruct(out float width, out float height) &#123; width &#x3D; Width; height &#x3D; Height; &#125;&#125; 如果需要调用解构器，则需使用如下的语法： 1234567var rect &#x3D; new Rectangle(3, 4);(float width, float height) &#x3D; rect; &#x2F;&#x2F; DeconstructionSystem.Console.WriteLine(width + &quot; &quot; + height);&#x2F;&#x2F; 相当于float width,height;rec.Deconstruct(out width,out height); 对象初始化 12345678910111213public class Bunny&#123; public string Name; public bool LikesCarrots; public bool LikesHumans; public Bunny() &#123; &#125; public Bunny(string n) &#x3D;&gt; name &#x3D; n;&#125;&#x2F;&#x2F; 初始化Bunny b1 &#x3D; new Bunny&#123;Name&#x3D;&quot;bo&quot;,LikesCarrots&#x3D;true,LikesHumans&#x3D;false&#125;;Bunny b2 &#x3D; new Bunny(&quot;bo&quot;) &#123; LikesCarrots&#x3D;true,LikesHumans&#x3D;false&#125;; 以上构造b1和b2的代码等价于： 1234567891011Bunny temp1 &#x3D; new Bunny();temp1.Name &#x3D; &quot;bo&quot;;temp1.LikesCarrots &#x3D; true;temp1.LikesHumans &#x3D; false;Bunny b1 &#x3D; temp1;Bunny temp2 &#x3D; new Bunny(&quot;bo&quot;);temp2.LikesCarrots &#x3D; true;temp2.LikesHumans &#x3D; false;Bunny b2 &#x3D; temp2; 使用临时变量是为了确保在初始化过程中如果抛出异常，则不会得到一个部分初始化的对象。 this引用 this引用指代示例本身。this引用仅在类或结构体的非静态成员中有效。 1234567891011&#x2F;&#x2F; Marry方法将partner的mate字段设定为thispublic class Panda&#123; public Panda Mate; public void Marry(Panda partner) &#123; Mate &#x3D; partner; partner.Mate &#x3D; this; &#125;&#125; 属性 属性和字段很类似，但是属性内部像方法一样含有逻辑。属性和字段的声明很类似，但是属性比字段多了get/set代码块。如果只定义了get访问器，属性就是只读的。如果只定义了set访问器，那么属性就是只写的（很少使用只写）。 12345678910public class Stock&#123; decimal currentPrice; public decimal CurrentPrice &#123; get &#123; return currentPrice;&#125; set &#123; currentPrice &#x3D; value;&#125; &#x2F;&#x2F; get和set是属性的访问器 &#125;&#125; 属性支持以下的修饰符： 静态修饰器：static 访问权限修饰符：public internal private protected 继承修饰符：new virtual abstract override sealed 非托管代码修饰符：unsafe extern 表达式属性（C#6和C#7) 从C#6开始，可以使用Expression-bodied形式来表示只读属性1public decimal Worth &#x3D;&gt; currentPrice * sharesOwned; C#7,允许set访问器也是用该形式12345public decimal Worth &#123; get &#x3D;&gt; currentPrice * sharesOwned; set &#x3D;&gt; sharesOwned &#x3D; value &#x2F; currentPrice;&#125; 自动属性：属性最常见的一种实践就是getter和setter只是对private field进行简单直接的读写 12345public class Stock&#123; ... public decimal CurrentPrice &#123; get;set;&#125;&#125; 从C#6开始，可以为自动属性添加属性初始化器 1public decimal CurrentPrice&#123;get;set;&#125; &#x3D; 123; 只读的自动属性也可以使用（只读自动属性也可以在构造函数里被赋值） 1public int Maximum &#123;get;&#125; &#x3D; 999; get和set的访问性： 可以与不同的访问级别。典型的用例是讲public属性中的set访问器设置成internal或private的： 123456789public class Foo&#123; private decimal x; public decimal X &#123; get&#123;return x;&#125; private set &#123; x &#x3D; Math.Round(value,2);&#125; &#125;&#125; 索引器 索引器提供了一种可以访问封装了列表值或字典值的class/struct的元素的语法。语法很像使用数组时的语法，但是这里的索引参数可以是任意类型的。 实现索引器：需要定义一个this属性，并通过中括号指定参数 1234567891011121314class Sentence&#123; string[] words &#x3D; &quot;The quick brown fox&quot;.Split(); public string this [int wordNum] &#123; get &#123; return words[wordNum];&#125; set &#123; words[wordNum] &#x3D; value;&#125; &#125;&#125;&#x2F;&#x2F; 索引器的使用Sentence s &#x3D; new Sentence();System.Console.WriteLine(s[3]); &#x2F;&#x2F; foxs[3] &#x3D; &quot;kangaroo&quot;; 一个类型可以定义多个参数类型不同的索引器，一个索引器也可以包含多个参数。 如果省略set访问器，则该索引器就是只读的，并且可以使用C#6的Expression-bodied来简化定义 public string this[int wordNum] =&gt; words[wordNum]; 常量 一个值不可以改变的静态字段 const关键字声明，声明时必须有初始值。 注意： 与const不同的是，static readonly字段的好处在于当提供给别的程序集时，可以在后续版本中更新其数值。假设程序集X提供了一个如下的常量： 1public const decimal ProgramVersion &#x3D; 2.3; 如果程序集Y引用了程序集X并使用了这个常量，那么值2.3将在编译时固定在程序集Y中。这意味着如果X后来重新编译将其值更改为2.4，那么Y仍将使用旧值2.3直至Y重新编译。而static readonly字段则不存在这个问题。 静态构造器（静态构造函数） 每个类型的静态构造器只会执行一次，而不是每个实例执行一次。一个类型只能定义一个静态 构造器，名称必须和类名同名，且没有参数。在类型使用之前的一瞬间，编译器会自动调用类型的静态构造函数：实例化一个类型或者访问类型的一个静态成员。静态构造器只支持两种修饰符：unsafe和extern 1234class Test&#123; static Test() &#123; Console.WriteLine(&quot;Type Initialized&quot;);&#125;&#125; 静态类：标记为static，其成员必须全是静态的，不可以有子类。比如System.Console和System.Math 终结器 Finalizer是class专有的一种方法，在GC回收未引用对象的内存之前运行。 1234567class Class1&#123; ~Class1 &#123; ... &#125;&#125; 事实上，这是C#语言重写Object类的Finalize方法的语法。编译器生成的 12345protected override void Finalize()&#123; ... base.Finalize();&#125; C#7可以这么写 ~Class1() =&gt; Console.WriteLine(“Finalizing”); 局部/分布类型 允许一个类型的定义分布在多个地方（文件） 典型应用：一个类的一部分是自动生成的，另一部分需要手动写代码 12345&#x2F;&#x2F; PaymentFormGen.cs - auto-generatedpartial class PaymentForm &#123;...&#125;&#x2F;&#x2F; PaymentFormGen.cs - hand-authoredpartial class PaymentForm &#123;...&#125; 注意 编译器无法保证各分布类的字段的初始化顺序 局部/分部方法： 自动生成的分布类里可以有partial method，通常作为”钩子“使用，在另一部分的partial method中，可以对这个方法进行定义。 123456789101112partial class PaymentForm &#x2F;&#x2F; In auto-generated file&#123; partial void ValidatePayment (decimal amount);&#125;partial class PaymentForm &#x2F;&#x2F; In hand-authored file&#123; partial void ValidatePayment (decimal amount) &#123; if (amount &gt; 100) ... &#125;&#125; partial method 由两部分组成：定义和实现 定义部分通常是生成的 实现部分通常是手动编写的 partial method 必须是void，并且隐式private的 nameof运算符 返回任何符号（类型、成员、变量…）的名字（string） 利于重构 String name = nameof (count); 类型转换和引用转换 一个对象的引用可以隐式的转换到其父类的引用（向上转换） 想转换到子类的引用则需要显式转换（向下转换） 引用转换：创建了一个新的引用，它也指向同一个对象 向上转换： 12Stock msft &#x3D; new Stock();Asset a &#x3D; msft; &#x2F;&#x2F; Asset是Stock的父类 变量a仍然指向同一个Stock对象 msft也指向它 向下转换： 123456Stock msft &#x3D; new Stock();Asset a &#x3D; msft; &#x2F;&#x2F; 向上转换Stock s &#x3D; (Stock)a; &#x2F;&#x2F; 向下转换 需要显式转换Console.WriteLine(s.SharesOwned); &#x2F;&#x2F; &lt;No error&gt;Console.WriteLine(s &#x3D;&#x3D;a ); &#x2F;&#x2F; TrueConsole.WriteLine(s &#x3D;&#x3D; msft ); &#x2F;&#x2F; True","categories":[],"tags":[]},{"title":"设计模式（未完）","slug":"设计模式（未完）","date":"2020-06-29T03:58:50.845Z","updated":"2020-06-29T03:57:42.841Z","comments":true,"path":"2020/06/29/设计模式（未完）/","link":"","permalink":"http://yoursite.com/2020/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/","excerpt":"","text":"设计模式 单例模式 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。类的构造方法一定不能是public的 ，只能是private。这个实例是当前类的类成员变量，静态变量 12345678910111213public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton; //唯一类变量 private Singleton()&#123;&#125; //构造方法私有 public static Singleton getInstance()&#123; return null; &#125;&#125; 单例模式的实例化时机分为饿汉式和懒汉式 1234567891011121314151617181920212223242526272829303132//饿汉式：在类加载的时候就进行实例化public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton = new Singleton(); //实例化 private Singleton()&#123;&#125; //构造方法私有 public static Singleton getInstance()&#123; return singleton;//返回singleton &#125;&#125;//懒汉式：在第一次使用的时候进行实例化public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton; private Singleton()&#123;&#125; //构造方法私有 public synchronized static Singleton getInstance()&#123; //加锁 if(singleton == null) singleton = new Singleton(); return singleton;//在第一次调用getInstance()方法时才进行实例化 &#125;&#125;","categories":[],"tags":[]},{"title":"vscode配置","slug":"vscode配置","date":"2020-06-28T12:23:48.182Z","updated":"2020-06-30T04:40:18.010Z","comments":true,"path":"2020/06/28/vscode配置/","link":"","permalink":"http://yoursite.com/2020/06/28/vscode%E9%85%8D%E7%BD%AE/","excerpt":"","text":"VSCode配置 更换主题 ctrl+shift+p 后输入Preferences Color Theme进行选择 图标主题 ctrl+shift+p 后输入Preferences File Icon Theme进行选择 生成构造函数 ctor 字号等设置 ctrl+， 自动保存 设置中 save搜索 在Auto Save选项中选择afterDelay 主命令框 F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下 Backspace 会进入到 Ctrl+P 模式 在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式 在 Ctrl+P 窗口下还可以: 直接输入文件名，跳转到文件 ? 列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol，也可以 Ctrl+T 常用快捷键 编辑器与窗口管理 打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 同时打开多个编辑器（查看多个文件） 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 切出一个新的编辑器（最多 3 个） Ctrl+\\，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名 左中右 3 个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+3 3 个编辑器之间循环切换 Ctrl+ 编辑器换位置， Ctrl+k然后按 Left或 Right 代码编辑 格式调整 代码行缩进 Ctrl+[ 、 Ctrl+] Ctrl+C 、 Ctrl+V 复制或剪切当前行/当前选中内容 代码格式化： Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code 上下移动一行： Alt+Up 或 Alt+Down 向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 在当前行下边插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 光标相关 移动到行首： Home 移动到行尾： End 移动到文件结尾： Ctrl+End 移动到文件开头： Ctrl+Home 移动到定义处： F12 定义处缩略图：只看一眼而不跳转过去 Alt+F12 移动到后半个括号： Ctrl+Shift+] 选择从光标到行尾： Shift+End 选择从行首到光标处： Shift+Home 删除光标右侧的所有字： Ctrl+Delete 扩展/缩小选取范围： Shift+Alt+Left 和 Shift+Alt+Right 多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 (在 sublime 中是删除当前行，后面自定义快键键中，设置与 Ctrl+Shift+K 互换了) 回退上一个光标操作： Ctrl+U 重构代码 找到所有的引用： Shift+F12 同时修改本文件中所有匹配的： Ctrl+F12 重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了 跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转 查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose 查找替换 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F 显示相关 全屏：F11 zoomIn/zoomOut：Ctrl +/- 侧边栏显/隐：Ctrl+B 显示资源管理器 Ctrl+Shift+E 显示搜索 Ctrl+Shift+F 显示 Git Ctrl+Shift+G 显示 Debug Ctrl+Shift+D 显示 Output Ctrl+Shift+U","categories":[],"tags":[]},{"title":"Java学习路线","slug":"Java学习路线","date":"2020-06-28T03:28:13.038Z","updated":"2020-06-29T06:30:30.403Z","comments":true,"path":"2020/06/28/Java学习路线/","link":"","permalink":"http://yoursite.com/2020/06/28/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"title：Java学习路线 测试字段","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-28T01:22:21.684Z","updated":"2020-06-28T01:22:21.684Z","comments":true,"path":"2020/06/28/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}