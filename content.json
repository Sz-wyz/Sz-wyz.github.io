{"meta":{"title":"Szwyz's Blog","subtitle":"蚍蜉撼树","description":"","author":"Szwyz","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-28T03:20:55.000Z","updated":"2020-06-28T03:25:10.105Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C#进阶（未完）","slug":"CSharp2（未完）","date":"2020-07-08T13:36:02.100Z","updated":"2020-07-08T13:35:45.112Z","comments":true,"path":"2020/07/08/CSharp2（未完）/","link":"","permalink":"http://yoursite.com/2020/07/08/CSharp2%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/","excerpt":"","text":"[TOC] 泛型 C#中在不同的类型复用代码有两种方法：继承和泛型。泛型：使用了带有（类型）占位符的模板 泛型会声明类型参数-泛型的消费者需要提供类型参数（argument）来把占位符类型填充上 12345678910public class Stack\\&lt;T&gt; &#x2F;&#x2F; 可以在不同的类型间进行复用&#123; int position; T[] data &#x3D; new T[100]; public void Push (T obj) &#x3D;&gt; data[position++] &#x3D; obj; public T Pop() &#x3D;&gt; data[--position];&#125;var stack &#x3D; new Stack&lt;int&gt;();stack.Push(5); Stack&lt;T&gt; Open Type（开放类型） Stack&lt;int&gt; Closed Type（封闭类型）// 在运行时，所有的泛型类型实例都是封闭的 泛型方法 泛型方法在方法的签名内也可以声明类型参数 12345678910static void Swap&lt;T&gt;(ref T a,ref T b)&#123; T temp &#x3D; a; a &#x3D; b; b &#x3D; temp;&#125;int x &#x3D; 5;int y &#x3D; 10;Swap(ref x,ref y); 声明类型参数 在声明class、struct、interface、delegate的时候可以引入类型参数 其他的例如属性，就不可以引入类型参数，但是可以使用类型参数1234public struct Nullable&lt;T&gt; &#x2F;&#x2F; struct可以引用&#123; public T Value &#123; get; &#125; &#x2F;&#x2F; 不可以引用，只可以使用&#125; 泛型类型/泛型方法可以有多个类型参数： 1class Dictionary&lt;TKey,Tvalue&gt;&#123;...&#125; 泛型类型/泛型方法的名称可以被重载，条件是参数类型的个数不同 123class A &#123;&#125;class A&lt;T&gt; &#123;&#125;class A&lt;T1,T2&gt; &#123;&#125; typeof和未绑定泛型类型 开放的泛型类型在编译后就变成了封闭的泛型类型 但是作为Type对象，那么未绑定的泛型类型在运行时是可以存在的。（只能通过typeof操作符来实现） 12345class A&lt;T&gt; &#123;&#125;class A&lt;T1,T2&gt; &#123;&#125;Type a1 &#x3D; typeof(A&lt;&gt;); &#x2F;&#x2F; 表示A&lt;T&gt;Type a2 &#x3D; typeof(A&lt;,&gt;); &#x2F;&#x2F; 对应A&lt;T1,T2&gt; 泛型的默认值：default关键字可以用于获取泛型类型参数的默认值。 array[i] = default(T) 泛型约束 默认情况下，泛型的类型参数可以是任何类型的。 如果只允许使用特定的类型参数，就可以指定约束123456where T:base-class &#x2F;&#x2F; T必须是某个父类的子类where T:interface &#x2F;&#x2F; T必须实现了某个接口where T:class &#x2F;&#x2F; T必须是引用类型where T:struct &#x2F;&#x2F; T是值类型（不包括可空值类型）where T:new() &#x2F;&#x2F; 里面必须有一个无参的构造函数where U:T &#x2F;&#x2F; 要求类型参数U继承类型参数T 裸类型约束： 12345class Stack&lt;T&gt;&#123; Stack&lt;U&gt; FilteredStack&lt;U&gt;() where U : T&#123;...&#125; &#x2F;&#x2F; 泛型方法FilteredStack有一个泛型参数U，要求U必须继承自T&#125; 泛型类型的子类 泛型class可以有子类，在子类里，可以继续让父类的类型参数保持开放 12class Stack&lt;T&gt; &#123;&#125;class SpecialStack&lt;T&gt; : Stack&lt;T&gt; &#123;&#125; 在子类里，也可以使用具体的类型来关闭（封闭）父类的类型参数 1class IntStack : Stack&lt;int&gt; &#123;&#125; 子类型也可以引入新的类型参数 自引用的泛型声明 在封闭类型参数的时候，该类型可以把它自己作为具体的类型 12345678910111213141516public interface IEquatable&lt;T&gt;&#123; bool Equals (T obj);&#125;public class Balloon : IEquatable&lt;Balloon&gt; &#x2F;&#x2F; 泛型参数T使用的就是Ballon&#123; public string Color &#123;get; set; &#125; public int CC &#123; get; set; &#125; public bool Equals (Ballon b) &#123; if(b &#x3D;&#x3D; null) return false; return b.Color &#x3D;&#x3D; Color &amp;&amp;b.CC &#x3D;&#x3D; CC; &#125;&#125; 静态数据：针对每一个封闭类型，静态数据是唯一的 123456789101112class Bob&lt;T&gt; &#123; public static int Count;&#125;class Test&#123; static void Main() &#123; Console.WriteLine(++Bob&lt;int&gt;.Count); &#x2F;&#x2F; 1 Console.WriteLine(++Bob&lt;int&gt;.Count); &#x2F;&#x2F; 2 Console.WriteLine(++Bob&lt;string&gt;.Count); &#x2F;&#x2F; 1 Console.WriteLine(++Bob&lt;object&gt;.Count); &#x2F;&#x2F; 1 &#125;&#125; 类型参数和转换 C#转换操作符支持下列转换： 数值转换 引用转换 装箱拆箱转换 自定义转换 决定采用的是哪种转换，发生在编译时，根据已知类型的操作数来决定 1234567891011121314StringBuilder Foo&lt;T&gt; (T arg)&#123; if (arg is StringBuilder ) return (StringBuilder )arg; &#x2F;&#x2F; will not compile&#125;&#x2F;&#x2F; 不知道T的具体类型，编译器可能认为做的自定义转换 使用as操作符StringBuilder Foo&lt;T&gt; (T arg)&#123; StringBuilder sb &#x3D; arg as StringBuilder; ...&#125;&#x2F;&#x2F; 更加一般的做法return (StringBuilder)(object)arg; 拆箱转换也可能导致二义性。例如以下代码可能是拆箱转换、数制转换或者自定义转换 123int Foo&lt;T&gt; (T x) &#x3D;&gt; (int)x; &#x2F;&#x2F; Compile-time errorint Foo&lt;T&gt; (T x) &#x3D;&gt; (int)(object)x; &#x2F;&#x2F; 解决办法 协变（未完） 逆变（未完） 不变（未完） C#泛型和C++模板对比 C#的泛型和C++的模板在应用上很相似，但是它们的工作原理却大不相同。两者都发生了生产者和消费者的关联，且生产者的占位符将被消费者填充。但是在C#泛型中，生产者的类型(开放类型如List&lt;T&gt;)可以编译到程序库中(如mscorlib.dII) 。这是因为生产者和消费者进行关联生成封闭类型是在运行时发生的。而C++模板中，这一关联是在编译时进行的。这意味着C++不能将模板库部署为. dll,它们只存在于源代码中。这令动态语法检查难以实现，更不用说即时创建或参数化类型了。 为了深究这一情形形成的原因，我们重新观察C#的Max方法： 1234static T Max &lt;T&gt; (T a, T b) where T: IComparable&lt;T&gt; &#x3D;&gt; a.CompareTo(b) &gt;0 ? a:b ;&#x2F;&#x2F;但是以下是错误的static T Max &lt;T&gt; (T a ,T b) &#x3D;&gt; (a&gt;b?a:b); &#x2F;&#x2F; Compile error 原因是，Max需要在编译时支持所有可能的T类型值。由于对于任意类型T，运算符&gt;没有统一的含义，因此上述程序无法通过编译。实际上，并不是所有的类型都支持&gt;运算符。相对的，下面的代码是用C++的模板编写的Max方法。而该代码会为每一个T值分别编译。对特定T呈现的不同的&gt;语义，而当T不支持&gt;运算符的时候，编译失败： 1234template &lt;class T&gt; T MAX (T a,T b)&#123; return a&gt;b?a:b;&#125; C#的高级特性 委托 委托是一个对象，它知道如何调用一个方法。 委托类型定义了委托实例可以调用的那类方法，具体来说，委托类型定义了方法的返回类型和参数。 123delegate int Transformer(int x);&#x2F;&#x2F; Transformer兼容任何返回类型为int并有一个int类型的参数的方法,比如如下方法static int Square(int x) &#x3D;&gt; x*x; 委托实例 把方法赋值给委托变量的时候就创建了委托实例 1234Transformer t &#x3D; Square;&#x2F;&#x2F;调用int answer &#x3D; t(3); &#x2F;&#x2F; 9 委托实例其实就是调用者的委托：调用者调用委托，然后委托调用目标方法。这样间接的把调用者和目标方法解耦了。 简写： 12345Transformer t &#x3D; Square; &#x2F;&#x2F; 简写Transformer t &#x3D; new Transformer(Square);t(3); &#x2F;&#x2F; 简写t.Invoke(3); 编写插件式的方法 方法是运行时才赋值给委托变量的 123456789101112131415161718192021222324public delegate int Transformer(int x);class Util&#123; public static void Transform(int[] values, Transformer t) &#123; for (int i &#x3D; 0; i &lt; values.Length; i++) values[i] &#x3D; t(values[i]); &#125;&#125;class Test&#123; static void Main() &#123; int[] values &#x3D; &#123; 1, 2, 3 &#125;; Util.Transform(values, Square); foreach (int i in values) Console.WriteLine(i + &quot; &quot;); &#125; static int Square(int x) &#x3D;&gt; x * x;&#125; 多播委托 所有委托实例都具有多播的能力。一个委托实例可以引用一组目标方法。 使用+=操作符可以合并委托实例： 1234&#x2F;&#x2F; 调用d就会调用SomeMethod1和SomeMethod2&#x2F;&#x2F; 委托的调用顺序与它们的定义顺序一致SomeDelegate d &#x3D; SomeMethod1;d +&#x3D; SomeMethod2; 使用-=操作符会把右边的委托从左边的委托里移除 1d -&#x3D; SomeMethod1; 委托是不可变的 使用+=或-=时，实质是创建一个新的委托实例，并把它赋值给已有变量 如果一个多播委托拥有非void的返回类型，则调用者将从最后一个触发的方法接收返回值。前面的方法仍然调用，但是返回值都会被丢弃。大部分调用多播委托的情况都会返回void类型，因此这个细小的差异就没有了。 实例方法目标和静态方法目标 当一个实例方法被赋值给委托对象的时候，这个委托对象不仅要保留对方法的引用，还要保留着方法所属实例的引用 System.Delegate的Target属性就代表着这个实例 如果引用的是静态方法，那么Target属性的值就是null 12345678910111213141516171819202122namespace Demo&#123; public delegate void ProgressReporter(int percentComplete); class X &#123; public void InstanceProgress(int percentComplete) &#x3D;&gt; Console.WriteLine(percentComplete); &#125; public class Program &#123; static void Main() &#123; X x &#x3D; new X(); ProgressReporter p &#x3D; x.InstanceProgress; p(99); Console.WriteLine(p.Target &#x3D;&#x3D; x); &#x2F;&#x2F; True Console.WriteLine(p.Method); &#x2F;&#x2F; Void InstanceProgress(Int32) 表示这个方法 &#125; &#125;&#125; 泛型委托类型 委托类型可以包含泛型类型参数 123456789101112131415161718192021222324252627namespace Demo&#123; public delegate T Transformer&lt;T&gt;(T arg); &#x2F;&#x2F; 返回类型T public class Util &#123; public static void Transform&lt;T&gt;(T[] values, Transformer&lt;T&gt; t) &#x2F;&#x2F; 泛型方法 &#123; for (int i &#x3D; 0; i &lt; values.Length; i++) &#123; values[i] &#x3D; t(values[i]); &#125; &#125; class Test &#123; static void Main() &#123; int[] values &#x3D; &#123; 1, 2, 3 &#125;; Util.Transform(values, Square); foreach (int i in values) Console.Write(i + &quot; &quot;); &#125; static int Square(int x) &#x3D;&gt; x * x; &#125; &#125;&#125; Func和Action委托（未完） 使用泛型委托，就可以写出这样一组委托类型，它们可调用的方法可以拥有任意的返回类型和任意（合理）数量的参数。 委托vs接口 委托可以解决的问题，接口都可以解决 在以下之一情况下，更适合使用委托： 接口只能定义一个方法 需要多播能力 订阅者需要多次实现接口 委托类型的兼容性 委托类型之间互不相容，即使方法签名一样 12345delegate void D1();delegate void D2();D1 d1 &#x3D; Method1;D2 d2 &#x3D; d1; &#x2F;&#x2F; Compile-time error 如果委托实例指向相同的目标方法，则认为它们是等价的，如果多播委托按照相同的顺序引用相同的方法，则认为它们是等价的。 12345delegate void D();...D d1 &#x3D; Method1;D d2 &#x3D; Method2;Console.WriteLine(d1 &#x3D;&#x3D; d2); &#x2F;&#x2F; true 调用方法时，你可以得到一个比请求的类型更具体的类型的返回结果。而委托的目标方法可以返回比委托描述里更具体的类型的返回结果，Covariance. 123456789101112131415namespace Demo&#123; delegate object ObjectRetriever(); class Test &#123; static void Main() &#123; ObjectRetriever o &#x3D; new ObjectRetriever(RetrieveString); object result &#x3D; o(); Console.WriteLine(result); &#125; static string RetrieveString() &#x3D;&gt; &quot;hello&quot;; &#125;&#125; 事件 使用委托的时候，通常会出现两个角色：广播者和订阅者 广播者包含一个委托字段，广播者通过调用委托爱决定什么时候进行广播 定于这是方法目标的接受者，订阅者可以决定何时开始或结束监听，方式是通过在委托上调用+=和-= 事件就是将上述模式正式化的一个语言特性。事件是一种结构，为了实现广播者/订阅者模型，它只暴露了所需的委托特性的部分子集。事件的主要目的就是防止订阅者之间相互干扰。 123456public delegate void PriceChangedHandler(decimal oldPrice,decimal newPrice);public class Broadcaster&#123; public event PriceChangeHandler PriceChanged; &#x2F;&#x2F; 声明一个事件&#125; 注意：在类的内外是区别对待的。Broadercaster类型里面的代码拥有对PriceChanged的完全访问权，在这里就把它当做委托。而Broadercaster类型以外的代码只能对PriceChanged这个事件执行 +=和-=操作。 标准的事件模式（未完） 为编写事件，.NET定义了一个标准的模式 System.EventArgs，一个预定义的框架类，除了静态的Empty属性外，没有其他成员 EventArgs是为事件传递信息的类的基类 1234567891011public class PriceChangedEventArgs : System.EventArgs&#123; public readonly decimal LastPrice; public readonly decimal NewPrice; public PriceChangedEventArgs (decimal lastPrice,decimal newPrice) &#123; LastPrice &#x3D; lastPrice; NewPrice &#x3D; newPrice; &#125;&#125; EventArgs子类就位后，下一步就是选择或者定义事件的委托。必须遵循三条规则： 返回类型是void 接受两个参数，第一个参数类型是object，第二个参数类型是EventArgs的子类。第一个参数表示时间的广播者，第二个参数包含需要传递的信息。 委托的名称必须以EventHandler结尾 框架定义了一个名为System.EventHadnler&lt;&gt;的泛型委托，该委托满足以上的三个条件： 12public delegate void EventHandler&lt;TEventArgs&gt; (object source,TEventArgs e)where TEventArgs : EventArgs; 接下来是定义选定委托类型的事件： 12345public class Stock&#123; ... public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;&#125; Lambda表达式 Lambda表达式是一种可以替代委托实例的匿名方法。编译器会立即将Lambda表达式转换为以下两种形式之- : 一个委托实例。 一个类型为Expression&lt;TDelegate&gt;的表达式树。 该表达式树将Lambda表达式内部的代码表现为一个可遍历的对象模型，因此Lambda表达式的解释可以延迟到运行时。 下面的委托类型： 12345delegate int Transformer(int i);&#x2F;&#x2F;可使用Lambda表达式x&#x3D;&gt;x*x赋值，也可以调用该表达式Transformer sqr &#x3D; x &#x3D;&gt; x*x;Consonle.WriteLine(sqr(3)); &#x2F;&#x2F; 9 实际上，编译器会通过编写一个私有方法来解析这个lambda表达式，然后把表达式移动到这个方法里。 Lambda表达式的形式: （参数） =&gt; 表达式或语句块 // 如果只有一个参数并且类型可推断的话，那么参数的小括号可以省略 Lambda表达式通常和与Func和Action委托一起使用 12Func&lt;string,string,int&gt; totalLength &#x3D; (s1,s2) &#x3D;&gt; s1.Length + s2.Length;int total &#x3D; totalLength(&quot;hello&quot;,&quot;world&quot;); &#x2F;&#x2F; 10 显式指定Lambda表达式的参数类型 当编译器无法推断Lambda表达式的参数类型时，就需要显式的指定Lambda表达式的参数类型 12345678910void Foo&lt;T&gt; (T x) &#123;&#125;void Bar&lt;T&gt; (Action&lt;T&gt; a) &#123;&#125;&#x2F;&#x2F; 以下代码无法通过编译，因为编译器无法推断x的类型Bar(x &#x3D;&gt; Foo(X));&#x2F;&#x2F; 可以通过显式指定x的类型来修正这个问题Bar((int x) &#x3D;&gt; Foo(x));&#x2F;&#x2F; 也可以指定泛型类型参数的类型Bar&lt;int&gt; (x&#x3D;&gt; Foo(x)); 捕获外部变量 lambda表达式可以引用本地的变量和所在方法的参数 123456static void Main()&#123; int factor &#x3D; 2; Func&lt;int,int&gt; multiplier &#x3D; n&#x3D;&gt; n * factor; Console.WriteLine(multiplier(3)); &#x2F;&#x2F; 6&#125; 被捕获的变量： 被Lambda表达式引用的外部变量叫做被捕获的变量（captured variables) 捕获了外部变量的lambda表达式叫做闭包 被捕获的变量是在委托被实际调用的时候才被计算，而不是在捕获的时候 1234int factor &#x3D; 2;Func&lt;int,int&gt; multiplier &#x3D; n &#x3D;&gt; n * factor ;factor &#x3D; 10;Console.WriteLine(multiplier(3)); &#x2F;&#x2F; 30 Lambda表达式本身也可以更新被捕获的变量 12345int seed &#x3D; 0;Func&lt;int&gt; natural &#x3D; () &#x3D;&gt; seed++; &#x2F;&#x2F; 没有参数所以（）Concole.WrieteLine(natural()); &#x2F;&#x2F; 0Concole.WrieteLine(natural()); &#x2F;&#x2F; 1Concole.WrieteLine(seed); &#x2F;&#x2F; 2 被捕获的变量的声明周期会被延长到和委托一样 Lambda表达式内的本地变量 在Lambda表达式内实例化的本地变量对于委托实例的每次调用来说都是唯一的。 1234567891011static Func&lt;int&gt; Natural()&#123; return() &#x3D;&gt; &#123;int seed &#x3D; 0; return seed++; &#125;;&#125;static void Main()&#123; Func&lt;int&gt; natural &#x3D; Natural(); Console.WriteLine(natural()); &#x2F;&#x2F; 0 Console.WriteLine(natural()); &#x2F;&#x2F; 0&#125; 捕获迭代变量 当捕获for循环的迭代变量时，C#会把这个变量当做是在循环外部定义的变量，这就意味着每次迭代捕获的都是同一个变量 123456Action[] actions &#x3D; new Action[3]; &#x2F;&#x2F; Action数组 可以容纳三个委托for (int i &#x3D;0; i &lt; 3; i++) actions[i] &#x3D; () &#x3D;&gt; Console.Write(i); &#x2F;&#x2F; 把输出这个Lambda表达式赋值给action委托foreach(Action a in actions) a(); &#x2F;&#x2F; 333 循环委托数组 如何解决？ 123456789Action[] actions &#x3D; new Action[3]; &#x2F;&#x2F; Action数组 可以容纳三个委托for (int i &#x3D;0; i &lt; 3; i++)&#123; int loopScopedi &#x3D; i; actions[i] &#x3D; () &#x3D;&gt; Console.Write(loopScopedi); &#125;foreach(Action a in actions) a(); &#x2F;&#x2F; 012 Lambda表达式和本地方法 本地方法是C#7的一个新特性。它和L ambda表达式在功能上有很多重复之处，但它有三个优点: 可以简单明了的进行递归 无需指定委托类型 性能开销略低一点 本地方法效率更高是因为它避兔了委托的间接调用(需要CPU周期,内存分配)。本地方法也可以访问所在方法的本地变量，而且无需编译器把被捕获的变量hoist到隐藏的类。 Try语句和异常 catch catch块可以访问一个Exception对象，这个Exception对象里含有关于错误的信息 catch块通常被用来对错误进行处理/补偿或者重新抛出异常 可以把异常类型和变量都拿掉，这就代表着会捕获所有的异常 catch {…..} finally finall块为程序增加了确定性:：CLR总是尽力去执行它。它通常用来做一些清理任务。 12345678910111213141516try&#123; ... &#x2F;&#x2F; 可能发生异常错误的代码&#125;catch (ExceptionA ex) &#x2F;&#x2F; 每个catch捕获一个特定异常&#123; ... &#x2F;&#x2F; handle exception of type ExceptionA&#125;catch (ExceptionB ex)&#123; ... &#x2F;&#x2F; handle exception of type ExceptionB&#125;finally&#123;... &#x2F;&#x2F; cleanup code&#125; 异常的过滤 从C#6开始，可以在catch子句中添加一个when子句来指定一个异常过滤器 1234catch (WebException ex) when (ex.Status &#x3D;&#x3D; WebExceptionStatus.Timeout)&#123; ... &#x2F;&#x2F;当when后面的布尔表达式true时才会执行&#125; 抛出异常 异常可以被运行时或者用户抛出 123456789101112131415161718class Test&#123; static void Display (string name ) &#123; if (nane &#x3D;&#x3D; null) throw new ArgunentNullException (naneof (nane)) ;&#x2F;&#x2F;用户抛出的异常 Console .WriteLine (name ); &#125; static void Main() &#123; try &#123; Display (null); &#125; catch (ArgumentNullException ex) &#123; Console .WriteLine (&quot;Caught the exception&quot;); &#125; &#125;&#125; C# 7之前，throw是个语句。而现在它可以作为expression-bodied functions里的一个表达式:public string Foo() =&gt; throw new NotImplementedException(); 重新抛出异常： 1234567try&#123;...&#125;catch (Exception ex)&#123; &#x2F;&#x2F; Log error ... throw; &#x2F;&#x2F; Rethrow same exception&#125; 如果使用throw ex代替throw的话，程序仍可运行，但是新传递的异常的Stacktrace属性就不会反应原始错误了。 System.Exception的关键属性 StackTrace 它是一个字符串，展现了从异常发生地到catch块所有被调用的方法 Message 关于错误的描述信息 InnerException 引起外层异常的内层异常(如果存在的话)。而且InnerException本身还有可能含有InnerException 枚举和迭代器 枚举 枚举器是一个只读的，作用于一序列值的、只能向前的游标。 枚举器是一个实现了下列任意-个接口的对象 System.Collections.lEnumerator System.Collections.Generic .IEnumerator&lt;T&gt; 技术上来说，任何一一个含有名为MoveNext方法和名为Current的属性的对象，都会被当作枚举器来对待。 foreach语句会迭代可枚举的对象(enumerable object)。可枚举的对象是一序列值的逻辑表示。它本身不是游标，它是一个可以基于本身产生游标的对象。 可枚举对象 一个可枚举对象可以是(下列任意一个)： 实现了IEnumerable或者IEnumerable&lt;T&gt;的对象。 有一个名为GetEnumerator的方法，并且该方法返回一个枚举器(enumerator) lEnumerator和lEnumerable是定义在System.Collections命名空间下的。 lEnumerator&lt;T&gt;和lEnumerable&lt;T&gt;是定义在System.Collections.Generic命名空间下的。 枚举模式 12345678910class Enumerator &#x2F;&#x2F; 枚举器 通常实现了IEnumerator或者Inumerator&lt;T&gt;&#123; public IteratorVariableType Current&#123; get&#123;...&#125;&#125; public bool MoveNext() &#123;...&#125;&#125;class Enumerable &#x2F;&#x2F; 可枚举的对象 通常实现了IEnumerable或者Inumerable&lt;T&gt;&#123; public Enumerator GetEnumerator() &#123;...&#125; &#x2F;&#x2F; 返回一个Enumerator&#125; 示例： 12345678910foreach (char C in &quot;beer&quot;) Console.WriteLine (C);using (var enumerator &#x3D; &quot;beer&quot;.GetEnumerator()) while ( enumerator.MoveNext()) &#123; var element &#x3D; enumerator.Current; Console .WriteLine (element); &#125; 集合初始化器 只需一步就可以把可枚举对象进行实例化并且填充里面的元素： 123456789using System.Collections.Generic;List&lt;int&gt; list &#x3D; new List&lt;int&gt;&#123;1,2,3&#125;;&#x2F;&#x2F; 但是编译器会把它翻译成using System.Collections.Generic;List&lt;int&gt; list &#x3D; new List&lt;int&gt;();list.Add(1);list.Add(2);list.Add(3); 迭代器Iterators（未完） foreach语句是枚举器(enumerator) 的消费者，而迭代器(iterator) 是枚举器的生产者。 拓展方法 扩展方法允许我们使用新的方法来扩展现有的类型,而且无需修改原有类型的定义. 扩展方法是静态类的一个静态方法，在静态方法里的第一个参数使用this修饰符， 第一个参数的类型就是要被扩展的类型. 示例： 1234567891011public static class StringHelper&#123; public static bool IsCapitalized(this string s) &#x2F;&#x2F; 扩展了string &#123; if (string.IsNullOrEmpty(s)) return false; return char.IsUpper(s[0]); &#125;&#125;&#x2F;&#x2F; 这里的IsCapitalized方法可以这样调用Console. Writeline (StringHelper.IsCapitalized (&quot;Perth&quot;));Console . WriteLine (&quot;Perth&quot;.IsCapitalized()); 拓展方法的实现原理：拓展方法的这种调用方式实际上是这样被编译的 12arg0.Method (arg1, arg2,…); &#x2F;&#x2F; Extension method callStaticClass.Method (arg0， arg1， arg2， ...); &#x2F;&#x2F; Static nethod call 歧义和解析命名空间 只有所在类处于在作用范围内的拓展方法才可以被访问，典型的做法是引入命名空间 12345678namespace MyApp&#123; using Utils; class Test &#123; static void Main() &#x3D;&gt; Console.WriteLine(&quot;Perth&quot;.IsCapitalized()); &#125;&#125; 拓展方法和实例方法 任何兼容的实例方法的优先级总是高于扩展方法。在下面的例子中，即使参数x类型为int也会优先调用Test的Fo方法： 12345678class Test&#123; public void Foo(objectx) &#123; &#125; &#x2F;&#x2F; This method always wins&#125;static class Extensions&#123; public static void Foo(this Testt, intx) &#123; &#125;&#125; 只能通过普通的静态调用来调用拓展方法：Extensions.Foo()； 拓展方法和拓展方法 如果两个扩展方法签名相同，则扩展方法必须作为一个普通的静态方法调用才能进行区分。当然，如果其中一个扩展方法具有更具体的参数，那么更具体参数的方法优先级更高。 匿名类型 匿名类型就是有编译器即时创建的一个class,它用来存储一组数据 创建匿名类型: new + object初始化器，并指定属性及其值 使用var关键字来引用匿名类，因为匿名类型没有名字 匿名类属性的名称可以通过本身就是标识符/以标识符结尾的表达式推断出来 在同一个assembly下声明的两个匿名类实例，如果它们的元素名和类型都完全一致，那么它们的基础类型(underlying type)就是一样的 Equals方法被重写来进行相等性的比较 可以创建匿名类型数组 方法不可以返回匿名类型的对象，必须使用dynamic或者object, 调用时依赖于动态绑定，并且会损失静态类型的安全性。 匿名类型主要用来写LINQ查询 元组（Tuple） Tuple提供了简单的方式来存储一组数据 使用Tuple的主要目的是从方法安全的返回多个值，而且无需使用out参数 C# 7的Tuple主要是依赖于一组支撑它的struct,叫做System.ValueTuple&lt;&gt; 123var bob&#x3D; (&quot;Bob&quot;, 23);: &#x2F;&#x2F; Allow compiler to infer the element typesConsole. WriteI ine (bob.Item1): &#x2F;&#x2F; BobConsole.WriteL ine (bob.Item2); &#x2F;&#x2F; 23 和匿名类型不同，可以将每一个元素的类型列在括号中，来显式指定元组的类型。 1(string,int)bob &#x3D; (&quot;Bob&quot;,23); 元组元素命名 当创建元组字面量时，可以为元组的元素起一些有意义的名字： 1var tuple &#x3D; (Name:&quot;Bob&quot;,Age:23); 也可以在指定元组类型时进行命名： 1static (string Name,int Age) GetPerson() &#x3D;&gt;(&quot;Bob&quot;,23); 类型擦除 C#使用了一组现存的泛型struct来处理Tuple public struct ValueTuple&lt;T1&gt; public struct ValueTuple&lt;T1,T2&gt; public struct ValueTuple&lt;T1,T2,T3&gt; … 每个ValueTuple&lt;&gt;struct都有Item1，Item2…等字段 因此，(string, int)是ValueTuple&lt;string, int&gt;的别名。同时，这意味着命名的元组元素并没有底层类型的命名属性的支撑。这些名字仅仅存在于源代码和编译器的想象”中。在运行时，这些名字大多会消失。当我们反编译引用命名元素的元组时，可以看到程序仅仅引用了Item1、Item2这样的字段。若将元组变量赋值给一个obect对象并在调试器 下观察(或者在LINQPad下输出)，就可以发现元素的名字完全消失了。因此，在绝大多数情况下，都不能用反射(reflection) 的方式确定元组在运行时的命名。 ValueTuple.Create 12ValueTuple&lt;string int&gt; bob1 &#x3D; ValueTuple.Create(&quot;Bob&quot;, 23):(string.int)bob2 &#x3D; ValueTuple.Create (&quot;Bob&quot;: 23); 元组的解构 1234var bob &#x3D; (&quot;Bob&quot;,23);(string name,int age) &#x3D; bob;Console.WriteLine(name); &#x2F;&#x2F; BobConsole.WriteLine(age); &#x2F;&#x2F; 23 特性（Attribute) Attribute是一种扩展机制，它可以为代码元素添加自定义的信息 一Assembly, 类型、成员、返回值、参数、泛型参数 一个很好的应用场景就是序列化 把任意一个对象转化为特定格式/从特定格式转化过来 特性类 一个Attribute是通过一个（直接或间接）继承了System.Attribute的类来定义的 把Attribute应用于代码元素 12[ObsoleteAttribute] &#x2F;&#x2F; 可省略为[Obsolete]public class Foo&#123;...&#125; 命名和位置Attribute参数 Attribute 可以有参数 12[XmlElement ( &quot;Customer&quot;，Namespace&#x3D;&quot;http: &#x2F;&#x2F;oreilly. com&quot;)]public class CustomerEntity &#123; ... &#125; Attribute的参数可以分为两类: 位置的和命名的位置参数对应Attribute类型的公共构造函数的参数命名参数对应Attribute类型的公共字段或公共属性当指定Attribute的时候， 必须包含与Attribute相应构造函数所对应的位置参数，而命名参数是可选的。 预处理指令（详见官方文档） 预处理器指令向编译器提供有关代码区域的附加信息。最常见的预处理器指令是条件指令，它提供了从编译中包含或排除代码区域的方法。预处理器符号可以在源文件中定义，也可以通过设定/define:symbol命令行选项进行定义。 1234567891011#define DEBUGclass MyClass&#123; int x; void Foo0() &#123; #if DEBUG Console.WriteLine(&quot;Testing:x&#x3D; &#123;0&#125; &quot;, x); #endif &#125;&#125;","categories":[],"tags":[]},{"title":"C#初阶","slug":"Csharp","date":"2020-07-05T14:14:11.687Z","updated":"2020-07-05T14:24:21.964Z","comments":true,"path":"2020/07/05/Csharp/","link":"","permalink":"http://yoursite.com/2020/07/05/Csharp/","excerpt":"[TOC] 编译 C#编译器是把.cs结尾的源码文件编译成Assembly Assembly是.NET Core里的包装和部署的单元 Assembly可以是应用程序，也可以是库 .exe .dll","text":"[TOC] 编译 C#编译器是把.cs结尾的源码文件编译成Assembly Assembly是.NET Core里的包装和部署的单元 Assembly可以是应用程序，也可以是库 .exe .dll C#基础 转换 转换始终会根据一个已经存在的值创建一个新的值。转换可以是显式的或隐式的：隐式转换自动发生而显示转换需要强制转换。 123int x &#x3D; 12345;long y &#x3D; x; &#x2F;&#x2F; 隐式转换short z &#x3D; (short)x; &#x2F;&#x2F; 显式转换 隐式转换只有在以下条件都满足时才会进行： 编译器能确保转换总能成功 没有信息在转换过程中丢失显示转换只有在以下条件都满足时才会进行： 编译器不能保证转换总是成功 信息在转换过程中可能有丢失 位运算符 C#支持的位运算符有： ~ 按位取反 &amp; 按位与 | 按位或 ^ 按位异或 &lt;&lt; 按位左移 &gt;&gt; 按位右移 ref修饰符 在C#中，若按引用传递参数则应使用ref参数修饰符。下面的例子中p和x指向同一块内存位置 123456789101112131415class Test&#123; static void Foo(ref int p) &#123; p &#x3D; p + 1; Console.WriteLine(p); &#x2F;&#x2F; 9 &#125; static void Main() &#123; int x &#x3D; 8; Foo(ref x); Console.WriteLine(x); &#x2F;&#x2F; 9 &#125;&#125; out修饰符 out参数不需要再传入函数之前进行赋值，必须在函数结束之前赋值。 1234567891011121314151617class Test&#123; static void Split(string name, out string firstNames, out string lastName) &#123; int i &#x3D; name.LastIndexOf(&#39; &#39;); firstNames &#x3D; name.Substring(0, i); lastName &#x3D; name.Substring(i + 1); &#125; static void Main() &#123; string a, b; Split(&quot;Stevie Ray Vaughan&quot;, out a, out b); Console.WriteLine(a); Console.WriteLine(b); &#125;&#125; params修饰符 params参数修饰符只能修饰方法中的最后一个参数，它能够使方法接受任意数量的指定参数类型。参数类型必须声明为数组。 1234567891011121314151617181920class Test&#123; static int Sum(params int[] ints) &#123; int sum &#x3D; 0; for (int i &#x3D; 0; i &lt; ints.Length; i++) sum +&#x3D; ints[i]; &#125; return sum; &#125; static void Main() &#123; int total &#x3D; Sum(1, 2, 3, 4); Console.WriteLine(total); &#125;&#125; null运算符 nullh合并运算符意思是如果操作数不是null则结果为操作数，否则结果为一个默认的值 12string s1 &#x3D; null;string s2 &#x3D; s1 ?? &quot;nothing&quot;; &#x2F;&#x2F;如果左侧的表达式不是null则右侧的表达式将不会进行计算 null条件运算符该运算符可以像标准的“.”运算符那样访问成员以及调用方法。当运算符的左侧为null时，该表达式的运算结果也是null而不会抛出NullReferenceException异常string s = sb?.ToString(); Null附加课程 可空值 类型 可空值类型是System.Nullable&lt;T&gt;这个struct的实例 可空值类型除了可以正确的表示其底层数据类型的范围，还可以表示null 例如 bool类型有True和False 而 Nullable&lt;bool&gt;有True、False和null 123456static void Main(string[] args) &#123; string str &#x3D; &quot;dsafdsafdsfsd&quot;; int? indexOfM &#x3D; null; &#x2F;&#x2F; 可空类型 Nullable&lt;int&gt; indexOFM &#x3D; null; &#x2F;&#x2F; 相当于这个 &#125; Null和空，空白string string name = “Nick”; string name = null; string name = “”; string name = “ “; 判断Null和空，空白string if(name==null){…} if(string.isNullOrEmpty(name)){…} if(string.isNullOrWhiteSpace(name)){…} Nullable&lt;T&gt;的常用属性和方法 .HasValue .Value // 底层值类型的值（不常用） .GetValueOrDefault() // 底层值类型的值或该类型的默认值 .GetValueOrDefault(默认值) // 底层值类型的值或指定的默认值 Nullable&lt;T&gt;转换 T-&gt;Nullable&lt;T&gt;隐式转换 Nullable&lt;T&gt;-&gt;T显式转换 123456789101112131415static void Main(string[] args) &#123; &#123; int i &#x3D; 3; int? j &#x3D; i; &#x2F;&#x2F; 隐式转换 Console.WriteLine(j); &#125; &#123; int? i &#x3D; 3; int j &#x3D; (int)i; &#x2F;&#x2F; 显式转换 Console.WriteLine(j); &#125; &#125; foreach循环 foreach语句遍历可枚举对象的每一个元素。 12foreach (char c in &quot;beer&quot;) Console.WriteLine(c); 在C#中创建类型 123class YourClassName&#123;&#125; 在class关键字之前：类特性（Attribute）和类修饰符。非嵌套的类修饰符有：public、internal、abstract、sealed、unsafe和partial 在{}内：类成员（方法、属性、索引器、事件、字段、构造器、重载运算符、嵌套类型和终结器） 字段是类或者结构体中的变量成员 12345class Octopus&#123; string name; public int Age &#x3D; 10;&#125; 字段可以以下修饰符进行修饰： 静态修饰符：static 访问权限修饰符：public internal private protected 继承修饰符：new 不安全代码修饰符：unsafe 只读修饰符：readonly //防止字段在构造后进行变更 线程访问修饰符：volatile 方法 方法通过指定的输出类型将输出数据返回给调用者，此外，方法还可以通过ref/out参数向调用者返回输出数据。 方法的签名在一个类中必须是唯一的。方法的签名由它的名字和一定顺序的参数类型（但不包含参数名和返回值类型）组成。 注意：方法的返回值类型和params修饰符不属于方法签名的一部分 12345void Foo(int x)&#123;...&#125;float Foo(int x)&#123;...&#125; &#x2F;&#x2F; Compile-time errorvoid Goo(int[] x)&#123;...&#125;void Goo(params int[] x)&#123;...&#125; &#x2F;&#x2F; Compile-time error 方法可以用一下修饰符修饰： 静态修饰符：static 访问权限修饰符：public internal private protected 继承修饰符：new virtual abstract override sealed 部分方法修饰符：partial 非托管代码修饰符：unsafe extern 异步代码修饰符：async expression-bodied方法（C#6) 1234567int Foo(int x) &#123; return x * 2; &#125; &#x2F;&#x2F;仅由一个表达式构成的方法&#x2F;&#x2F;可用双箭头来却带花括号和returnint Foo(int x) &#x3D;&gt; x*2;&#x2F;&#x2F;void返回类型也可支持void Foo(int x) &#x3D;&gt; Console.WriteLine(x); 按值传递和按引用传递 参数按值传递还是按引用传递也是方法签名的一部分。例如Foo(int)和Foo(ref int)或者Foo(out int)可以出现在一个类中。但是Foo(ref int)和Foo(out int)不能同时出现在一个类中。 123void Foo(int x)&#123;...&#125;void Foo(ref int x)&#123;...&#125; &#x2F;&#x2F; OK so farvoid Foo(out int x)&#123;...&#125; &#x2F;&#x2F; Compile-time error 局部方法（C#7） C#7开始允许一个方法中定义另外一个方法。局部方法不能用static修饰 123456void WriteCubes()&#123; Console.WriteLine(Cube(3)); int Cube(int value) &#x3D;&gt; value*value*value;&#125; 实例构造器（构造函数） 12345678910public class Panda&#123; string name; public Panda(string n) &#x2F;&#x2F; 构造器名和返回值只能和封装类的类型相同 &#123; name &#x3D; n; &#125;&#125;Panda p &#x3D; new Panda(&quot;petey&quot;); 实例构造器支持一下的修饰符： 访问权限修饰符：public internal private protected 非托管代码修饰符：unsafe extern 也可这么写：public Panda(string n) =&gt; name = n;构造器的重载：为了避免代码重复，构造器可以用this关键字来调用另一个构造器 1234567891011using System;public class Wine&#123; public decimal Price; public int Year; public Wine(decimal price)&#123; Price &#x3D; price;&#125; public Wine(decimal price,int year):this (price)&#123;Year &#x3D; year;&#125; &#x2F;&#x2F; 还可以向另一个构造器传递表达式 public Wine(decimal price,DateTime year):this (price,year.Year)&#123;&#125;&#125; 非公有构造器 ：在C#中，构造器不添加修饰符，则默认是private类型的。非共有构造器通常用在单例设计中 12345public class Class1&#123; Class1()&#123;&#125; &#x2F;&#x2F; private constructro public static Class1 Create(...)&#123;...&#125;&#125; 解构器（析构函数） 解析方法的名字必须是Deconstruct,并且拥有一个或多个out参数。 123456789101112131415class Rectangle&#123; public readonly float Width, Height; public Rectangle(float width, float height) &#123; Width &#x3D; width; Height &#x3D; height; &#125; public void Deconstruct(out float width, out float height) &#123; width &#x3D; Width; height &#x3D; Height; &#125;&#125; 如果需要调用解构器，则需使用如下的语法： 1234567var rect &#x3D; new Rectangle(3, 4);(float width, float height) &#x3D; rect; &#x2F;&#x2F; DeconstructionSystem.Console.WriteLine(width + &quot; &quot; + height);&#x2F;&#x2F; 相当于float width,height;rec.Deconstruct(out width,out height); 对象初始化 12345678910111213public class Bunny&#123; public string Name; public bool LikesCarrots; public bool LikesHumans; public Bunny() &#123; &#125; public Bunny(string n) &#x3D;&gt; name &#x3D; n;&#125;&#x2F;&#x2F; 初始化Bunny b1 &#x3D; new Bunny&#123;Name&#x3D;&quot;bo&quot;,LikesCarrots&#x3D;true,LikesHumans&#x3D;false&#125;;Bunny b2 &#x3D; new Bunny(&quot;bo&quot;) &#123; LikesCarrots&#x3D;true,LikesHumans&#x3D;false&#125;; 以上构造b1和b2的代码等价于： 1234567891011Bunny temp1 &#x3D; new Bunny();temp1.Name &#x3D; &quot;bo&quot;;temp1.LikesCarrots &#x3D; true;temp1.LikesHumans &#x3D; false;Bunny b1 &#x3D; temp1;Bunny temp2 &#x3D; new Bunny(&quot;bo&quot;);temp2.LikesCarrots &#x3D; true;temp2.LikesHumans &#x3D; false;Bunny b2 &#x3D; temp2; 使用临时变量是为了确保在初始化过程中如果抛出异常，则不会得到一个部分初始化的对象。 this引用 this引用指代示例本身。this引用仅在类或结构体的非静态成员中有效。 1234567891011&#x2F;&#x2F; Marry方法将partner的mate字段设定为thispublic class Panda&#123; public Panda Mate; public void Marry(Panda partner) &#123; Mate &#x3D; partner; partner.Mate &#x3D; this; &#125;&#125; 属性 属性和字段很类似，但是属性内部像方法一样含有逻辑。属性和字段的声明很类似，但是属性比字段多了get/set代码块。如果只定义了get访问器，属性就是只读的。如果只定义了set访问器，那么属性就是只写的（很少使用只写）。 12345678910public class Stock&#123; decimal currentPrice; public decimal CurrentPrice &#123; get &#123; return currentPrice;&#125; set &#123; currentPrice &#x3D; value;&#125; &#x2F;&#x2F; get和set是属性的访问器 &#125;&#125; 属性支持以下的修饰符： 静态修饰器：static 访问权限修饰符：public internal private protected 继承修饰符：new virtual abstract override sealed 非托管代码修饰符：unsafe extern 表达式属性（C#6和C#7) 从C#6开始，可以使用Expression-bodied形式来表示只读属性1public decimal Worth &#x3D;&gt; currentPrice * sharesOwned; C#7,允许set访问器也是用该形式12345public decimal Worth &#123; get &#x3D;&gt; currentPrice * sharesOwned; set &#x3D;&gt; sharesOwned &#x3D; value &#x2F; currentPrice;&#125; 自动属性：属性最常见的一种实践就是getter和setter只是对private field进行简单直接的读写 12345public class Stock&#123; ... public decimal CurrentPrice &#123; get;set;&#125;&#125; 从C#6开始，可以为自动属性添加属性初始化器 1public decimal CurrentPrice&#123;get;set;&#125; &#x3D; 123; 只读的自动属性也可以使用（只读自动属性也可以在构造函数里被赋值） 1public int Maximum &#123;get;&#125; &#x3D; 999; get和set的访问性： 可以与不同的访问级别。典型的用例是讲public属性中的set访问器设置成internal或private的： 123456789public class Foo&#123; private decimal x; public decimal X &#123; get&#123;return x;&#125; private set &#123; x &#x3D; Math.Round(value,2);&#125; &#125;&#125; 索引器 索引器提供了一种可以访问封装了列表值或字典值的class/struct的元素的语法。语法很像使用数组时的语法，但是这里的索引参数可以是任意类型的。 实现索引器：需要定义一个this属性，并通过中括号指定参数 1234567891011121314class Sentence&#123; string[] words &#x3D; &quot;The quick brown fox&quot;.Split(); public string this [int wordNum] &#123; get &#123; return words[wordNum];&#125; set &#123; words[wordNum] &#x3D; value;&#125; &#125;&#125;&#x2F;&#x2F; 索引器的使用Sentence s &#x3D; new Sentence();System.Console.WriteLine(s[3]); &#x2F;&#x2F; foxs[3] &#x3D; &quot;kangaroo&quot;; 一个类型可以定义多个参数类型不同的索引器，一个索引器也可以包含多个参数。 如果省略set访问器，则该索引器就是只读的，并且可以使用C#6的Expression-bodied来简化定义 public string this[int wordNum] =&gt; words[wordNum]; 常量 一个值不可以改变的静态字段 const关键字声明，声明时必须有初始值。 注意： 与const不同的是，static readonly字段的好处在于当提供给别的程序集时，可以在后续版本中更新其数值。假设程序集X提供了一个如下的常量： 1public const decimal ProgramVersion &#x3D; 2.3; 如果程序集Y引用了程序集X并使用了这个常量，那么值2.3将在编译时固定在程序集Y中。这意味着如果X后来重新编译将其值更改为2.4，那么Y仍将使用旧值2.3直至Y重新编译。而static readonly字段则不存在这个问题。 静态构造器（静态构造函数） 每个类型的静态构造器只会执行一次，而不是每个实例执行一次。一个类型只能定义一个静态 构造器，名称必须和类名同名，且没有参数。在类型使用之前的一瞬间，编译器会自动调用类型的静态构造函数：实例化一个类型或者访问类型的一个静态成员。静态构造器只支持两种修饰符：unsafe和extern 1234class Test&#123; static Test() &#123; Console.WriteLine(&quot;Type Initialized&quot;);&#125;&#125; 静态类：标记为static，其成员必须全是静态的，不可以有子类。比如System.Console和System.Math 终结器 Finalizer是class专有的一种方法，在GC回收未引用对象的内存之前运行。 1234567class Class1&#123; ~Class1 &#123; ... &#125;&#125; 事实上，这是C#语言重写Object类的Finalize方法的语法。编译器生成的 12345protected override void Finalize()&#123; ... base.Finalize();&#125; C#7可以这么写 ~Class1() =&gt; Console.WriteLine(“Finalizing”); 局部/分布类型 允许一个类型的定义分布在多个地方（文件） 典型应用：一个类的一部分是自动生成的，另一部分需要手动写代码 12345&#x2F;&#x2F; PaymentFormGen.cs - auto-generatedpartial class PaymentForm &#123;...&#125;&#x2F;&#x2F; PaymentFormGen.cs - hand-authoredpartial class PaymentForm &#123;...&#125; 注意 编译器无法保证各分布类的字段的初始化顺序 局部/分部方法： 自动生成的分布类里可以有partial method，通常作为”钩子“使用，在另一部分的partial method中，可以对这个方法进行定义。 123456789101112partial class PaymentForm &#x2F;&#x2F; In auto-generated file&#123; partial void ValidatePayment (decimal amount);&#125;partial class PaymentForm &#x2F;&#x2F; In hand-authored file&#123; partial void ValidatePayment (decimal amount) &#123; if (amount &gt; 100) ... &#125;&#125; partial method 由两部分组成：定义和实现 定义部分通常是生成的 实现部分通常是手动编写的 partial method 必须是void，并且隐式private的 nameof运算符 返回任何符号（类型、成员、变量…）的名字（string） 利于重构 String name = nameof (count); 类型转换和引用转换 一个对象的引用可以隐式的转换到其父类的引用（向上转换） 想转换到子类的引用则需要显式转换（向下转换） 引用转换：创建了一个新的引用，它也指向同一个对象 向上转换： 12Stock msft &#x3D; new Stock();Asset a &#x3D; msft; &#x2F;&#x2F; Asset是Stock的父类 变量a仍然指向同一个Stock对象 msft也指向它 向下转换：（从父类的引用创建出子类的引用） 123456Stock msft &#x3D; new Stock();Asset a &#x3D; msft; &#x2F;&#x2F; 向上转换Stock s &#x3D; (Stock)a; &#x2F;&#x2F; 向下转换 需要显式转换Console.WriteLine(s.SharesOwned); &#x2F;&#x2F; &lt;No error&gt;Console.WriteLine(s &#x3D;&#x3D;a ); &#x2F;&#x2F; TrueConsole.WriteLine(s &#x3D;&#x3D; msft ); &#x2F;&#x2F; True 需要显式转换，因为可能会失败，如果向下转换失败，那么就会抛出InvalidCastException（属于运行时类型检查） AS操作符： as操作符会执行向下转换，如果转换失败，不会抛出异常，值会变成null 12Asset a &#x3D; new Asset(); &#x2F;&#x2F; Asset是父类 Stock继承自StockStock s &#x3D; a as Stock; &#x2F;&#x2F; s is null;no exception thrown as操作符无法做自定义转换：long x = 3 as long；// Compile-time error IS操作符：is操作符会检验引用的转换是否成功。换句话说，判断对象是否派生于某个类（或者实现了某个接口）通常用于向下转换前的验证： 12if (a is Stock) Console.WriteLine(((Stock)a).SharesOwned); C#7里，在使用is操作符的时候，可以引用一个变量 12if (a is Stock s) &#x2F;&#x2F; 如果a是stock类型，那么就将a赋值为s Console.WriteLine(s.SharesOwned); Virtual函数成员 标记为virtual的函数可以被子类重写，包括方法、属性、索引器、事件 12345public class Asset&#123; public string Name; public virtual decimal Liability &#x3D;&gt; 0;&#125; 之后在子类中就可以用override修饰符进行重写： 12345public class House:Asset&#123; public decimal Mortgage; public override decimal Liability &#x3D;&gt; Mortgage;&#125; virtual方法和重写方法的签名、返回类型、可访问程度必须是一样的。重写方法里使用base关键字可以调用父类的实现。 抽象类和抽象成员 使用abstract声明的类是抽象类 抽象类不可以被实例化，只有其具体的子类才可以实例化 抽象类可以定义抽象成员 抽象成员和virtual成员很像，但是不提供具体的实现。子类必须提供实现，除非子类也是抽象的。12345678910111213public abstract class Asset&#123; public abstract decimal NetValue&#123; get;&#125;&#125;public class Stock:Asset&#123; public long SharesOwned; public decimal CurrentPrice; &#x2F;&#x2F;Override like a virtual method public override decimal NetValue &#x3D;&gt; CurrentPrice * SharesOwned;&#125; 隐藏被继承的成员：父类和子类可以定义相同的成员（编译器会发出警告）： 12public class A &#123; public int counter &#x3D; 1; &#125;public class B:A &#123;public int Counter &#x3D; 2; &#125; 如果想故意隐藏父类的成员，可以在子类的成员前面加上new修饰符（抑制编译器的警告） 12public class A &#123; public int counter &#x3D; 1; &#125;public class B:A &#123;public new int Counter &#x3D; 2; &#125; sealed关键字：针对重写的成员，可以使用sealed关键字把它密封起来，防止被其他子类重写。sealed也可以密封整个类。public sealed override decimal Liability { get {return Mortgage;} } base关键字：base主要用于从子类访问父类被重写的函数、调用父类的构造函数 1234public class House : Asset&#123; public override decimal Liability &#x3D;&gt; base.Liability + Mortgage;&#125; 构造函数和继承 子类必须声明自己的构造函数 从子类可访问父类的构造函数，但不是自动继承的 子类必须重新定义它想要暴露的构造函数123456789public class Baseclass&#123; public int X; public Baseclass() &#123; &#125; public Baseclass(int x) &#123; this.X &#x3D; x; &#125;&#125;public class Subclass : Baseclass &#123; &#125;Subclass s &#x3D; new Subclass(123); &#x2F;&#x2F; 非法的 调用父类的构造函数需要使用base关键字，父类的构造函数肯定会先执行 1234public class Subclass : Baseclass&#123; public Subclass(int x) : base(x) &#123; &#125;&#125; 如果子类的构造函数里没有使用base关键字，那么父类的无参构造函数会被隐式的调用，如果父类没有无参构造函数，那么子类就必须在构造函数里使用base关键字 object类型 object（System.Object）是所有类型的终极父类。所有类型都可以向上转换为object 1234567public class Stack &#x2F;&#x2F; 一个可以容纳10个对象的栈的实现&#123; int position; object[] data &#x3D; new object[10]; public void Push(object obj) &#123; data[position] &#x3D; obj; &#125; public object Pop() &#123; return data[--position]; &#125;&#125; 由于Stack类操作的对象是object，所以可以实现Push或Pop任意类型的实例的操作。 1234Stack stack &#x3D; new Stack();stack.Push(&quot;sausage&quot;);string s &#x3D; (string)stack.Pop();Console.WriteLine(s); 装箱和拆箱 装箱是将值类型实例转换为引用类型实例的行为。 拆箱正好相反，把那个对象转化为原来的值类型，需要显式的转换 1234int x &#x3D; 9;object obj &#x3D; x; &#x2F;&#x2F; Box the intint y &#x3D; (int)obj; &#x2F;&#x2F; Unbox the int GetType和typeof运算符 所有C#的类型在运行时都是以System.Type的实例来展现的 两种方式可以获得System.Type对象： 在实例上调用GetType()方法 在类型名上使用typeof操作符 GetType是在运行时被算出的 typeof是在编译时被算出（静态）（当涉及到泛型类型参数时，它是由即时编译器来解析的） 123456789101112131415using System;public class Point&#123;public int X,Y;&#125;class Test&#123; static void Main() &#123; Point p &#x3D; new Point(); Console.WriteLine(p.GetType().Name); &#x2F;&#x2F; point Console.WriteLine(typeof(Point).Name); &#x2F;&#x2F; point Console.WriteLine(p.X.GetType().Name); &#x2F;&#x2F; Int32 Console.WriteLine(p.Y.GetType().FullName); &#x2F;&#x2F; System.Int32 &#125;&#125; 结构体 结构体的构建： struct有一个无参的构造函数，但是不能对其重写，它会对字段进行按位归零操作 当你定义struct构造函数的时候，必须显式的为每个字段赋值 不可以有字段初始化器 12345678&#x2F;&#x2F; 错误的例子public struct Point&#123; int x &#x3D; 1; &#x2F;&#x2F; 不可有初始化器 int y; public Point() &#123;&#125; &#x2F;&#x2F; 不可以写无参的构造函数 public Point(int x ) &#123;this.x &#x3D; x;&#125; &#x2F;&#x2F; 没有对y进行初始化&#125; 访问权限修饰符 public，完全可访问。枚举类型的成员和接口的成员默认都是这个级别 internal，当前程序集或友元程序集可访问，非嵌套类型的默认访问级别 private，本类可访问。class和struct的成员的默认访问级别 protected，本类或其子类可以访问 protected internal，联合了protected和internal的访问级别 友元程序集 通过添加System.Runtime.CompilerServices.InternalsVisibleTo这个Assembly的属性，并指定朋友Assembly的名字，就可以把internal的成员暴露给朋友Assembly 1[assembly: InternalsVisibleTo(&quot;Friend&quot;)] 接口 接口与class类似，但是它只为其成员提供了规格，而没有提供具体的实现 接口的成员都是隐式抽象的 一个class或者struct可以实现多个接口 123456public interface IEnumerator&#123; bool MoveNext(); object Current &#123; get; &#125; void Reset();&#125; 接口成员都是隐式public的，不可以声明访问修饰符。注意，实现接口意味着它将为所有的成员提供public实现。 1234567internal class Countdown : IEnumerator&#123; int count &#x3D; 11; public bool MoveNext() &#x3D;&gt; count--&gt;0; public object Current &#x3D;&gt; count; public void Reset() &#123; throw new NotSupportedException(); &#125;&#125; 接口的拓展（继承）： 12public interface IUndoable &#123; void Undo(); &#125;public interface IRedoable:IUndoable &#123; void Redo(); &#125; 显式的接口实现 实现多个接口的时候可能会造成成员签名的冲突。通过显式实现接口成员可以解决这个问题。 12345678910111213141516interface T1 &#123; void Foo(); &#125;interface T2 &#123; int Foo(); &#125;public class Widget:T1, T2&#123; public void Foo &#123; Console.WriteLine(&quot;Widget&#39;s implementation of T1.Foo&quot;); &#125; int T2.Foo &#123; Console.WriteLine(&quot;Widget&#39;s implementation of T2.Foo&quot;); return 1; &#125;&#125; 显式接口实现： 123456789101112131415161718192021222324252627282930313233343536using System;namespace ConsoleApp1&#123; public interface IFoo &#123; void Do(); &#125; public interface IBar &#123; int Do(); &#125; public class Parent : IFoo, IBar &#123; public void Do() &#x3D;&gt; Console.WriteLine(&quot;Foo&quot;); int IBar.Do() &#x2F;&#x2F; 显式的接口实现 &#123; Console.WriteLine(&quot;Bar&quot;); return 0; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Parent p &#x3D; new Parent(); p.Do(); &#x2F;&#x2F; Foo ((IBar)p).Do(); &#x2F;&#x2F; Bar 接口的显式实现 ((IFoo)p).Do(); &#x2F;&#x2F; Foo &#125; &#125;&#125; virtual的实现接口成员： 隐式实现的接口成员默认是sealed的 如果想要重写的话，必须在基类中把成员标记为virtual或者abstract 1234567891011public interface IUndoable &#123; void Undo(); &#125;public class TextBox : IUndoable &#x2F;&#x2F; 接口实现的类默认是sealed的&#123; public virtual void Undo() &#x3D;&gt; Console.WriteLine (&quot;TextBox.Undo&quot;);&#125;public class RichTextBox : TextBox &#x2F;&#x2F; 要重写就必须把基类的成员标记为virtual或者abstract&#123; public override void Undo() &#x3D;&gt; Console.WriteLine(&quot;RichTextBox.Undo&quot;);&#125; 在子类中重新实现接口： 子类可以重新实现父类已经实现的接口成员 1234567891011public interface IUndoable &#123; void Undo(); &#125;public class TextBox : IUndoable&#123; void IUndoable.Undo() &#x3D;&gt; Console.WriteLine(&quot;TextBox.Undo&quot;);&#125;public class RichTextBox : TextBox, IUndoable &#x2F;&#x2F; 重写&#123; public void Undo() &#x3D;&gt; Console.WriteLine(&quot;RichTextBox.Undo&quot;);&#125; 从接口调用重新实现的成员时，调用的是子类的实现 123RichTextBox r &#x3D; new RichTextBox();r.Undo; &#x2F;&#x2F; RichTextBox.Undo((IUndoable)r).Undo(); &#x2F;&#x2F; RichTextBox.Undo 此时已经被重写 假定RichTextBox定义不变，如果TextBox隐式实现Undo: 1234public class TextBox : IUndoable&#123; public void Undo() &#x3D;&gt; Console.WriteLine(&quot;TextBox.Undo&quot;);&#125; 那么就有了另外一种调用Undo方法 1234RichTextBox r &#x3D; new RichTextBox();r.Undo; &#x2F;&#x2F; RichTextBox.Undo((IUndoable)r).Undo(); &#x2F;&#x2F; RichTextBox.Undo((TextBox)r).Undo(); &#x2F;&#x2F; TextBox.Undo 接口与装箱： 把struct转化为接口会导致装箱 调用struct上隐式实现的成员不会导致装箱 1234567interface I &#123; void Foo(); &#125;struct S : I &#123; public void Foo() &#123;&#125; &#125;...S s &#x3D; new S();s.Foo(); &#x2F;&#x2F; No boxing 调用struct上隐式实现的成员不会导致装箱I i &#x3D; s; &#x2F;&#x2F; Box occurs struct转化为接口会导致装箱 枚举和嵌套类型 枚举一个特殊的值类型，可以指定一组命名的数值常量。 0,1,2,3会按照枚举成员的声明顺序自动赋值 也可以指定其他的类型作为枚举的整数类型，例如byte public enum BorderSide : byte { Left, Right, Top, Bottom } 也可以单独指定枚举成员对应的值 public enum BorderSide : byte { Left=1, Right=2, Top=10, Bottom=11 } 也可以指定集中某些成员的数值，未被赋值的成员将接着它前面已赋值成员的值递增 枚举类型转换： 枚举类型的实例可以与它对应的整数值相互显示转换： 12int i &#x3D; (int) BorderSide.Left;BorderSide side &#x3D; (BorderSide)i; 嵌套类型 嵌套类型是声明在另一个类型内部的类型。 可访问外层类型的私有成员，以及外层类所能访问的东西 可以使用所有的访问修饰符来声明 从外层累以外访问嵌套类型需要使用外层类名称进行限定（就像访问静态成员那样）","categories":[],"tags":[]},{"title":"设计模式","slug":"设计模式（未完）","date":"2020-06-29T03:58:50.845Z","updated":"2020-07-12T05:11:14.174Z","comments":true,"path":"2020/06/29/设计模式（未完）/","link":"","permalink":"http://yoursite.com/2020/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/","excerpt":"设计模式 单例模式 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。类的构造方法一定不能是public的 ，只能是private。这个实例是当前类的类成员变量，静态变量 12345678910111213public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton; //唯一类变量 private Singleton()&#123;&#125; //构造方法私有 public static Singleton getInstance()&#123; return null; &#125;&#125;","text":"设计模式 单例模式 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。类的构造方法一定不能是public的 ，只能是private。这个实例是当前类的类成员变量，静态变量 12345678910111213public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton; //唯一类变量 private Singleton()&#123;&#125; //构造方法私有 public static Singleton getInstance()&#123; return null; &#125;&#125; 单例模式的实例化时机分为饿汉式和懒汉式 1234567891011121314151617181920212223242526272829303132//饿汉式：在类加载的时候就进行实例化public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton = new Singleton(); //实例化 private Singleton()&#123;&#125; //构造方法私有 public static Singleton getInstance()&#123; return singleton;//返回singleton &#125;&#125;//懒汉式：在第一次使用的时候进行实例化public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton; private Singleton()&#123;&#125; //构造方法私有 public synchronized static Singleton getInstance()&#123; //加锁 if(singleton == null) singleton = new Singleton(); return singleton;//在第一次调用getInstance()方法时才进行实例化 &#125;&#125;","categories":[],"tags":[]},{"title":"vscode配置","slug":"vscode配置","date":"2020-06-28T12:23:48.182Z","updated":"2020-07-05T08:25:50.513Z","comments":true,"path":"2020/06/28/vscode配置/","link":"","permalink":"http://yoursite.com/2020/06/28/vscode%E9%85%8D%E7%BD%AE/","excerpt":"VSCode配置 更换主题 ctrl+shift+p 后输入Preferences Color Theme进行选择 图标主题 ctrl+shift+p 后输入Preferences File Icon Theme进行选择","text":"VSCode配置 更换主题 ctrl+shift+p 后输入Preferences Color Theme进行选择 图标主题 ctrl+shift+p 后输入Preferences File Icon Theme进行选择 生成构造函数 ctor 字号等设置 ctrl+， 自动保存 设置中 save搜索 在Auto Save选项中选择afterDelay 主命令框 F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下 Backspace 会进入到 Ctrl+P 模式 在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式 在 Ctrl+P 窗口下还可以: 直接输入文件名，跳转到文件 ? 列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol，也可以 Ctrl+T 常用快捷键 编辑器与窗口管理 打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 同时打开多个编辑器（查看多个文件） 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 切出一个新的编辑器（最多 3 个） Ctrl+\\，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名 左中右 3 个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+3 3 个编辑器之间循环切换 Ctrl+ 编辑器换位置， Ctrl+k然后按 Left或 Right 代码编辑 格式调整 代码行缩进 Ctrl+[ 、 Ctrl+] Ctrl+C 、 Ctrl+V 复制或剪切当前行/当前选中内容 代码格式化： Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code 上下移动一行： Alt+Up 或 Alt+Down 向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 在当前行下边插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 光标相关 移动到行首： Home 移动到行尾： End 移动到文件结尾： Ctrl+End 移动到文件开头： Ctrl+Home 移动到定义处： F12 定义处缩略图：只看一眼而不跳转过去 Alt+F12 移动到后半个括号： Ctrl+Shift+] 选择从光标到行尾： Shift+End 选择从行首到光标处： Shift+Home 删除光标右侧的所有字： Ctrl+Delete 扩展/缩小选取范围： Shift+Alt+Left 和 Shift+Alt+Right 多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 (在 sublime 中是删除当前行，后面自定义快键键中，设置与 Ctrl+Shift+K 互换了) 回退上一个光标操作： Ctrl+U 重构代码 找到所有的引用： Shift+F12 同时修改本文件中所有匹配的： Ctrl+F12 重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了 跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转 查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose 查找替换 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F 显示相关 全屏：F11 zoomIn/zoomOut：Ctrl +/- 侧边栏显/隐：Ctrl+B 显示资源管理器 Ctrl+Shift+E 显示搜索 Ctrl+Shift+F 显示 Git Ctrl+Shift+G 显示 Debug Ctrl+Shift+D 显示 Output Ctrl+Shift+U","categories":[],"tags":[]},{"title":"Java学习路线","slug":"Java学习路线","date":"2020-06-28T03:28:13.038Z","updated":"2020-06-29T06:30:30.403Z","comments":true,"path":"2020/06/28/Java学习路线/","link":"","permalink":"http://yoursite.com/2020/06/28/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"title：Java学习路线 测试字段","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-28T01:22:21.684Z","updated":"2020-07-05T08:08:27.414Z","comments":true,"path":"2020/06/28/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}