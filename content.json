{"meta":{"title":"Szwyz's Blog","subtitle":"蚍蜉撼树","description":"","author":"Szwyz","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-28T03:20:55.000Z","updated":"2020-06-28T03:25:10.105Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C#学习笔记","slug":"C#学习笔记","date":"2020-07-05T06:33:16.132Z","updated":"2020-07-05T08:25:12.207Z","comments":true,"path":"2020/07/05/C#学习笔记/","link":"","permalink":"http://yoursite.com/2020/07/05/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"[TOC] 编译 C#编译器是把.cs结尾的源码文件编译成Assembly Assembly是.NET Core里的包装和部署的单元 Assembly可以是应用程序，也可以是库 .exe .dll","text":"[TOC] 编译 C#编译器是把.cs结尾的源码文件编译成Assembly Assembly是.NET Core里的包装和部署的单元 Assembly可以是应用程序，也可以是库 .exe .dll C#基础 转换 转换始终会根据一个已经存在的值创建一个新的值。转换可以是显式的或隐式的：隐式转换自动发生而显示转换需要强制转换。 123int x &#x3D; 12345;long y &#x3D; x; &#x2F;&#x2F; 隐式转换short z &#x3D; (short)x; &#x2F;&#x2F; 显式转换 隐式转换只有在以下条件都满足时才会进行： 编译器能确保转换总能成功 没有信息在转换过程中丢失显示转换只有在以下条件都满足时才会进行： 编译器不能保证转换总是成功 信息在转换过程中可能有丢失 位运算符 C#支持的位运算符有： ~ 按位取反 &amp; 按位与 | 按位或 ^ 按位异或 &lt;&lt; 按位左移 &gt;&gt; 按位右移 ref修饰符 在C#中，若按引用传递参数则应使用ref参数修饰符。下面的例子中p和x指向同一块内存位置 123456789101112131415class Test&#123; static void Foo(ref int p) &#123; p &#x3D; p + 1; Console.WriteLine(p); &#x2F;&#x2F; 9 &#125; static void Main() &#123; int x &#x3D; 8; Foo(ref x); Console.WriteLine(x); &#x2F;&#x2F; 9 &#125;&#125; out修饰符 out参数不需要再传入函数之前进行赋值，必须在函数结束之前赋值。 1234567891011121314151617class Test&#123; static void Split(string name, out string firstNames, out string lastName) &#123; int i &#x3D; name.LastIndexOf(&#39; &#39;); firstNames &#x3D; name.Substring(0, i); lastName &#x3D; name.Substring(i + 1); &#125; static void Main() &#123; string a, b; Split(&quot;Stevie Ray Vaughan&quot;, out a, out b); Console.WriteLine(a); Console.WriteLine(b); &#125;&#125; params修饰符 params参数修饰符只能修饰方法中的最后一个参数，它能够使方法接受任意数量的指定参数类型。参数类型必须声明为数组。 1234567891011121314151617181920class Test&#123; static int Sum(params int[] ints) &#123; int sum &#x3D; 0; for (int i &#x3D; 0; i &lt; ints.Length; i++) sum +&#x3D; ints[i]; &#125; return sum; &#125; static void Main() &#123; int total &#x3D; Sum(1, 2, 3, 4); Console.WriteLine(total); &#125;&#125; null运算符 nullh合并运算符意思是如果操作数不是null则结果为操作数，否则结果为一个默认的值 12string s1 &#x3D; null;string s2 &#x3D; s1 ?? &quot;nothing&quot;; &#x2F;&#x2F;如果左侧的表达式不是null则右侧的表达式将不会进行计算 null条件运算符该运算符可以像标准的“.”运算符那样访问成员以及调用方法。当运算符的左侧为null时，该表达式的运算结果也是null而不会抛出NullReferenceException异常string s = sb?.ToString(); Null附加课程 可空值 类型 可空值类型是System.Nullable&lt;T&gt;这个struct的实例 可空值类型除了可以正确的表示其底层数据类型的范围，还可以表示null 例如 bool类型有True和False 而 Nullable&lt;bool&gt;有True、False和null 123456static void Main(string[] args) &#123; string str &#x3D; &quot;dsafdsafdsfsd&quot;; int? indexOfM &#x3D; null; &#x2F;&#x2F; 可空类型 Nullable&lt;int&gt; indexOFM &#x3D; null; &#x2F;&#x2F; 相当于这个 &#125; Null和空，空白string string name = “Nick”; string name = null; string name = “”; string name = “ “; 判断Null和空，空白string if(name==null){…} if(string.isNullOrEmpty(name)){…} if(string.isNullOrWhiteSpace(name)){…} Nullable&lt;T&gt;的常用属性和方法 .HasValue .Value // 底层值类型的值（不常用） .GetValueOrDefault() // 底层值类型的值或该类型的默认值 .GetValueOrDefault(默认值) // 底层值类型的值或指定的默认值 Nullable&lt;T&gt;转换 T-&gt;Nullable&lt;T&gt;隐式转换 Nullable&lt;T&gt;-&gt;T显式转换 123456789101112131415static void Main(string[] args) &#123; &#123; int i &#x3D; 3; int? j &#x3D; i; &#x2F;&#x2F; 隐式转换 Console.WriteLine(j); &#125; &#123; int? i &#x3D; 3; int j &#x3D; (int)i; &#x2F;&#x2F; 显式转换 Console.WriteLine(j); &#125; &#125; foreach循环 foreach语句遍历可枚举对象的每一个元素。 12foreach (char c in &quot;beer&quot;) Console.WriteLine(c); 在C#中创建类型 123class YourClassName&#123;&#125; 在class关键字之前：类特性（Attribute）和类修饰符。非嵌套的类修饰符有：public、internal、abstract、sealed、unsafe和partial 在{}内：类成员（方法、属性、索引器、事件、字段、构造器、重载运算符、嵌套类型和终结器） 字段是类或者结构体中的变量成员 12345class Octopus&#123; string name; public int Age &#x3D; 10;&#125; 字段可以以下修饰符进行修饰： 静态修饰符：static 访问权限修饰符：public internal private protected 继承修饰符：new 不安全代码修饰符：unsafe 只读修饰符：readonly //防止字段在构造后进行变更 线程访问修饰符：volatile 方法 方法通过指定的输出类型将输出数据返回给调用者，此外，方法还可以通过ref/out参数向调用者返回输出数据。 方法的签名在一个类中必须是唯一的。方法的签名由它的名字和一定顺序的参数类型（但不包含参数名和返回值类型）组成。 注意：方法的返回值类型和params修饰符不属于方法签名的一部分 12345void Foo(int x)&#123;...&#125;float Foo(int x)&#123;...&#125; &#x2F;&#x2F; Compile-time errorvoid Goo(int[] x)&#123;...&#125;void Goo(params int[] x)&#123;...&#125; &#x2F;&#x2F; Compile-time error 方法可以用一下修饰符修饰： 静态修饰符：static 访问权限修饰符：public internal private protected 继承修饰符：new virtual abstract override sealed 部分方法修饰符：partial 非托管代码修饰符：unsafe extern 异步代码修饰符：async expression-bodied方法（C#6) 1234567int Foo(int x) &#123; return x * 2; &#125; &#x2F;&#x2F;仅由一个表达式构成的方法&#x2F;&#x2F;可用双箭头来却带花括号和returnint Foo(int x) &#x3D;&gt; x*2;&#x2F;&#x2F;void返回类型也可支持void Foo(int x) &#x3D;&gt; Console.WriteLine(x); 按值传递和按引用传递 参数按值传递还是按引用传递也是方法签名的一部分。例如Foo(int)和Foo(ref int)或者Foo(out int)可以出现在一个类中。但是Foo(ref int)和Foo(out int)不能同时出现在一个类中。 123void Foo(int x)&#123;...&#125;void Foo(ref int x)&#123;...&#125; &#x2F;&#x2F; OK so farvoid Foo(out int x)&#123;...&#125; &#x2F;&#x2F; Compile-time error 局部方法（C#7） C#7开始允许一个方法中定义另外一个方法。局部方法不能用static修饰 123456void WriteCubes()&#123; Console.WriteLine(Cube(3)); int Cube(int value) &#x3D;&gt; value*value*value;&#125; 实例构造器（构造函数） 12345678910public class Panda&#123; string name; public Panda(string n) &#x2F;&#x2F; 构造器名和返回值只能和封装类的类型相同 &#123; name &#x3D; n; &#125;&#125;Panda p &#x3D; new Panda(&quot;petey&quot;); 实例构造器支持一下的修饰符： 访问权限修饰符：public internal private protected 非托管代码修饰符：unsafe extern 也可这么写：public Panda(string n) =&gt; name = n;构造器的重载：为了避免代码重复，构造器可以用this关键字来调用另一个构造器 1234567891011using System;public class Wine&#123; public decimal Price; public int Year; public Wine(decimal price)&#123; Price &#x3D; price;&#125; public Wine(decimal price,int year):this (price)&#123;Year &#x3D; year;&#125; &#x2F;&#x2F; 还可以向另一个构造器传递表达式 public Wine(decimal price,DateTime year):this (price,year.Year)&#123;&#125;&#125; 非公有构造器 ：在C#中，构造器不添加修饰符，则默认是private类型的。非共有构造器通常用在单例设计中 12345public class Class1&#123; Class1()&#123;&#125; &#x2F;&#x2F; private constructro public static Class1 Create(...)&#123;...&#125;&#125; 解构器（析构函数） 解析方法的名字必须是Deconstruct,并且拥有一个或多个out参数。 123456789101112131415class Rectangle&#123; public readonly float Width, Height; public Rectangle(float width, float height) &#123; Width &#x3D; width; Height &#x3D; height; &#125; public void Deconstruct(out float width, out float height) &#123; width &#x3D; Width; height &#x3D; Height; &#125;&#125; 如果需要调用解构器，则需使用如下的语法： 1234567var rect &#x3D; new Rectangle(3, 4);(float width, float height) &#x3D; rect; &#x2F;&#x2F; DeconstructionSystem.Console.WriteLine(width + &quot; &quot; + height);&#x2F;&#x2F; 相当于float width,height;rec.Deconstruct(out width,out height); 对象初始化 12345678910111213public class Bunny&#123; public string Name; public bool LikesCarrots; public bool LikesHumans; public Bunny() &#123; &#125; public Bunny(string n) &#x3D;&gt; name &#x3D; n;&#125;&#x2F;&#x2F; 初始化Bunny b1 &#x3D; new Bunny&#123;Name&#x3D;&quot;bo&quot;,LikesCarrots&#x3D;true,LikesHumans&#x3D;false&#125;;Bunny b2 &#x3D; new Bunny(&quot;bo&quot;) &#123; LikesCarrots&#x3D;true,LikesHumans&#x3D;false&#125;; 以上构造b1和b2的代码等价于： 1234567891011Bunny temp1 &#x3D; new Bunny();temp1.Name &#x3D; &quot;bo&quot;;temp1.LikesCarrots &#x3D; true;temp1.LikesHumans &#x3D; false;Bunny b1 &#x3D; temp1;Bunny temp2 &#x3D; new Bunny(&quot;bo&quot;);temp2.LikesCarrots &#x3D; true;temp2.LikesHumans &#x3D; false;Bunny b2 &#x3D; temp2; 使用临时变量是为了确保在初始化过程中如果抛出异常，则不会得到一个部分初始化的对象。 this引用 this引用指代示例本身。this引用仅在类或结构体的非静态成员中有效。 1234567891011&#x2F;&#x2F; Marry方法将partner的mate字段设定为thispublic class Panda&#123; public Panda Mate; public void Marry(Panda partner) &#123; Mate &#x3D; partner; partner.Mate &#x3D; this; &#125;&#125; 属性 属性和字段很类似，但是属性内部像方法一样含有逻辑。属性和字段的声明很类似，但是属性比字段多了get/set代码块。如果只定义了get访问器，属性就是只读的。如果只定义了set访问器，那么属性就是只写的（很少使用只写）。 12345678910public class Stock&#123; decimal currentPrice; public decimal CurrentPrice &#123; get &#123; return currentPrice;&#125; set &#123; currentPrice &#x3D; value;&#125; &#x2F;&#x2F; get和set是属性的访问器 &#125;&#125; 属性支持以下的修饰符： 静态修饰器：static 访问权限修饰符：public internal private protected 继承修饰符：new virtual abstract override sealed 非托管代码修饰符：unsafe extern 表达式属性（C#6和C#7) 从C#6开始，可以使用Expression-bodied形式来表示只读属性1public decimal Worth &#x3D;&gt; currentPrice * sharesOwned; C#7,允许set访问器也是用该形式12345public decimal Worth &#123; get &#x3D;&gt; currentPrice * sharesOwned; set &#x3D;&gt; sharesOwned &#x3D; value &#x2F; currentPrice;&#125; 自动属性：属性最常见的一种实践就是getter和setter只是对private field进行简单直接的读写 12345public class Stock&#123; ... public decimal CurrentPrice &#123; get;set;&#125;&#125; 从C#6开始，可以为自动属性添加属性初始化器 1public decimal CurrentPrice&#123;get;set;&#125; &#x3D; 123; 只读的自动属性也可以使用（只读自动属性也可以在构造函数里被赋值） 1public int Maximum &#123;get;&#125; &#x3D; 999; get和set的访问性： 可以与不同的访问级别。典型的用例是讲public属性中的set访问器设置成internal或private的： 123456789public class Foo&#123; private decimal x; public decimal X &#123; get&#123;return x;&#125; private set &#123; x &#x3D; Math.Round(value,2);&#125; &#125;&#125; 索引器 索引器提供了一种可以访问封装了列表值或字典值的class/struct的元素的语法。语法很像使用数组时的语法，但是这里的索引参数可以是任意类型的。 实现索引器：需要定义一个this属性，并通过中括号指定参数 1234567891011121314class Sentence&#123; string[] words &#x3D; &quot;The quick brown fox&quot;.Split(); public string this [int wordNum] &#123; get &#123; return words[wordNum];&#125; set &#123; words[wordNum] &#x3D; value;&#125; &#125;&#125;&#x2F;&#x2F; 索引器的使用Sentence s &#x3D; new Sentence();System.Console.WriteLine(s[3]); &#x2F;&#x2F; foxs[3] &#x3D; &quot;kangaroo&quot;; 一个类型可以定义多个参数类型不同的索引器，一个索引器也可以包含多个参数。 如果省略set访问器，则该索引器就是只读的，并且可以使用C#6的Expression-bodied来简化定义 public string this[int wordNum] =&gt; words[wordNum]; 常量 一个值不可以改变的静态字段 const关键字声明，声明时必须有初始值。 注意： 与const不同的是，static readonly字段的好处在于当提供给别的程序集时，可以在后续版本中更新其数值。假设程序集X提供了一个如下的常量： 1public const decimal ProgramVersion &#x3D; 2.3; 如果程序集Y引用了程序集X并使用了这个常量，那么值2.3将在编译时固定在程序集Y中。这意味着如果X后来重新编译将其值更改为2.4，那么Y仍将使用旧值2.3直至Y重新编译。而static readonly字段则不存在这个问题。 静态构造器（静态构造函数） 每个类型的静态构造器只会执行一次，而不是每个实例执行一次。一个类型只能定义一个静态 构造器，名称必须和类名同名，且没有参数。在类型使用之前的一瞬间，编译器会自动调用类型的静态构造函数：实例化一个类型或者访问类型的一个静态成员。静态构造器只支持两种修饰符：unsafe和extern 1234class Test&#123; static Test() &#123; Console.WriteLine(&quot;Type Initialized&quot;);&#125;&#125; 静态类：标记为static，其成员必须全是静态的，不可以有子类。比如System.Console和System.Math 终结器 Finalizer是class专有的一种方法，在GC回收未引用对象的内存之前运行。 1234567class Class1&#123; ~Class1 &#123; ... &#125;&#125; 事实上，这是C#语言重写Object类的Finalize方法的语法。编译器生成的 12345protected override void Finalize()&#123; ... base.Finalize();&#125; C#7可以这么写 ~Class1() =&gt; Console.WriteLine(“Finalizing”); 局部/分布类型 允许一个类型的定义分布在多个地方（文件） 典型应用：一个类的一部分是自动生成的，另一部分需要手动写代码 12345&#x2F;&#x2F; PaymentFormGen.cs - auto-generatedpartial class PaymentForm &#123;...&#125;&#x2F;&#x2F; PaymentFormGen.cs - hand-authoredpartial class PaymentForm &#123;...&#125; 注意 编译器无法保证各分布类的字段的初始化顺序 局部/分部方法： 自动生成的分布类里可以有partial method，通常作为”钩子“使用，在另一部分的partial method中，可以对这个方法进行定义。 123456789101112partial class PaymentForm &#x2F;&#x2F; In auto-generated file&#123; partial void ValidatePayment (decimal amount);&#125;partial class PaymentForm &#x2F;&#x2F; In hand-authored file&#123; partial void ValidatePayment (decimal amount) &#123; if (amount &gt; 100) ... &#125;&#125; partial method 由两部分组成：定义和实现 定义部分通常是生成的 实现部分通常是手动编写的 partial method 必须是void，并且隐式private的 nameof运算符 返回任何符号（类型、成员、变量…）的名字（string） 利于重构 String name = nameof (count); 类型转换和引用转换 一个对象的引用可以隐式的转换到其父类的引用（向上转换） 想转换到子类的引用则需要显式转换（向下转换） 引用转换：创建了一个新的引用，它也指向同一个对象 向上转换： 12Stock msft &#x3D; new Stock();Asset a &#x3D; msft; &#x2F;&#x2F; Asset是Stock的父类 变量a仍然指向同一个Stock对象 msft也指向它 向下转换：（从父类的引用创建出子类的引用） 123456Stock msft &#x3D; new Stock();Asset a &#x3D; msft; &#x2F;&#x2F; 向上转换Stock s &#x3D; (Stock)a; &#x2F;&#x2F; 向下转换 需要显式转换Console.WriteLine(s.SharesOwned); &#x2F;&#x2F; &lt;No error&gt;Console.WriteLine(s &#x3D;&#x3D;a ); &#x2F;&#x2F; TrueConsole.WriteLine(s &#x3D;&#x3D; msft ); &#x2F;&#x2F; True 需要显式转换，因为可能会失败，如果向下转换失败，那么就会抛出InvalidCastException（属于运行时类型检查） AS操作符： as操作符会执行向下转换，如果转换失败，不会抛出异常，值会变成null 12Asset a &#x3D; new Asset(); &#x2F;&#x2F; Asset是父类 Stock继承自StockStock s &#x3D; a as Stock; &#x2F;&#x2F; s is null;no exception thrown as操作符无法做自定义转换：long x = 3 as long；// Compile-time error IS操作符：is操作符会检验引用的转换是否成功。换句话说，判断对象是否派生于某个类（或者实现了某个接口）通常用于向下转换前的验证： 12if (a is Stock) Console.WriteLine(((Stock)a).SharesOwned); C#7里，在使用is操作符的时候，可以引用一个变量 12if (a is Stock s) &#x2F;&#x2F; 如果a是stock类型，那么就将a赋值为s Console.WriteLine(s.SharesOwned); Virtual函数成员 标记为virtual的函数可以被子类重写，包括方法、属性、索引器、事件 12345public class Asset&#123; public string Name; public virtual decimal Liability &#x3D;&gt; 0;&#125; 之后在子类中就可以用override修饰符进行重写： 12345public class House:Asset&#123; public decimal Mortgage; public override decimal Liability &#x3D;&gt; Mortgage;&#125; virtual方法和重写方法的签名、返回类型、可访问程度必须是一样的。重写方法里使用base关键字可以调用父类的实现。 抽象类和抽象成员 使用abstract声明的类是抽象类 抽象类不可以被实例化，只有其具体的子类才可以实例化 抽象类可以定义抽象成员 抽象成员和virtual成员很像，但是不提供具体的实现。子类必须提供实现，除非子类也是抽象的。12345678910111213public abstract class Asset&#123; public abstract decimal NetValue&#123; get;&#125;&#125;public class Stock:Asset&#123; public long SharesOwned; public decimal CurrentPrice; &#x2F;&#x2F;Override like a virtual method public override decimal NetValue &#x3D;&gt; CurrentPrice * SharesOwned;&#125; 隐藏被继承的成员：父类和子类可以定义相同的成员（编译器会发出警告）： 12public class A &#123; public int counter &#x3D; 1; &#125;public class B:A &#123;public int Counter &#x3D; 2; &#125; 如果想故意隐藏父类的成员，可以在子类的成员前面加上new修饰符（抑制编译器的警告） 12public class A &#123; public int counter &#x3D; 1; &#125;public class B:A &#123;public new int Counter &#x3D; 2; &#125; sealed关键字：针对重写的成员，可以使用sealed关键字把它密封起来，防止被其他子类重写。sealed也可以密封整个类。public sealed override decimal Liability { get {return Mortgage;} } base关键字：base主要用于从子类访问父类被重写的函数、调用父类的构造函数 1234public class House : Asset&#123; public override decimal Liability &#x3D;&gt; base.Liability + Mortgage;&#125; 构造函数和继承 子类必须声明自己的构造函数 从子类可访问父类的构造函数，但不是自动继承的 子类必须重新定义它想要暴露的构造函数123456789public class Baseclass&#123; public int X; public Baseclass() &#123; &#125; public Baseclass(int x) &#123; this.X &#x3D; x; &#125;&#125;public class Subclass : Baseclass &#123; &#125;Subclass s &#x3D; new Subclass(123); &#x2F;&#x2F; 非法的 调用父类的构造函数需要使用base关键字，父类的构造函数肯定会先执行 1234public class Subclass : Baseclass&#123; public Subclass(int x) : base(x) &#123; &#125;&#125; 如果子类的构造函数里没有使用base关键字，那么父类的无参构造函数会被隐式的调用，如果父类没有无参构造函数，那么子类就必须在构造函数里使用base关键字 object类型 object（System.Object）是所有类型的终极父类。所有类型都可以向上转换为object 1234567public class Stack &#x2F;&#x2F; 一个可以容纳10个对象的栈的实现&#123; int position; object[] data &#x3D; new object[10]; public void Push(object obj) &#123; data[position] &#x3D; obj; &#125; public object Pop() &#123; return data[--position]; &#125;&#125; 由于Stack类操作的对象是object，所以可以实现Push或Pop任意类型的实例的操作。 1234Stack stack &#x3D; new Stack();stack.Push(&quot;sausage&quot;);string s &#x3D; (string)stack.Pop();Console.WriteLine(s); 装箱和拆箱 装箱是将值类型实例转换为引用类型实例的行为。 拆箱正好相反，把那个对象转化为原来的值类型，需要显式的转换 1234int x &#x3D; 9;object obj &#x3D; x; &#x2F;&#x2F; Box the intint y &#x3D; (int)obj; &#x2F;&#x2F; Unbox the int GetType和typeof运算符 所有C#的类型在运行时都是以System.Type的实例来展现的 两种方式可以获得System.Type对象： 在实例上调用GetType()方法 在类型名上使用typeof操作符 GetType是在运行时被算出的 typeof是在编译时被算出（静态）（当涉及到泛型类型参数时，它是由即时编译器来解析的） 123456789101112131415using System;public class Point&#123;public int X,Y;&#125;class Test&#123; static void Main() &#123; Point p &#x3D; new Point(); Console.WriteLine(p.GetType().Name); &#x2F;&#x2F; point Console.WriteLine(typeof(Point).Name); &#x2F;&#x2F; point Console.WriteLine(p.X.GetType().Name); &#x2F;&#x2F; Int32 Console.WriteLine(p.Y.GetType().FullName); &#x2F;&#x2F; System.Int32 &#125;&#125; 结构体 结构体的构建： struct有一个无参的构造函数，但是不能对其重写，它会对字段进行按位归零操作 当你定义struct构造函数的时候，必须显式的为每个字段赋值 不可以有字段初始化器 12345678&#x2F;&#x2F; 错误的例子public struct Point&#123; int x &#x3D; 1; &#x2F;&#x2F; 不可有初始化器 int y; public Point() &#123;&#125; &#x2F;&#x2F; 不可以写无参的构造函数 public Point(int x ) &#123;this.x &#x3D; x;&#125; &#x2F;&#x2F; 没有对y进行初始化&#125; 访问权限修饰符 public，完全可访问。枚举类型的成员和接口的成员默认都是这个级别 internal，当前程序集或友元程序集可访问，非嵌套类型的默认访问级别 private，本类可访问。class和struct的成员的默认访问级别 protected，本类或其子类可以访问 protected internal，联合了protected和internal的访问级别 友元程序集 通过添加System.Runtime.CompilerServices.InternalsVisibleTo这个Assembly的属性，并指定朋友Assembly的名字，就可以把internal的成员暴露给朋友Assembly 1[assembly: InternalsVisibleTo(&quot;Friend&quot;)] 接口 接口与class类似，但是它只为其成员提供了规格，而没有提供具体的实现 接口的成员都是隐式抽象的 一个class或者struct可以实现多个接口 123456public interface IEnumerator&#123; bool MoveNext(); object Current &#123; get; &#125; void Reset();&#125; 接口成员都是隐式public的，不可以声明访问修饰符。注意，实现接口意味着它将为所有的成员提供public实现。 1234567internal class Countdown : IEnumerator&#123; int count &#x3D; 11; public bool MoveNext() &#x3D;&gt; count--&gt;0; public object Current &#x3D;&gt; count; public void Reset() &#123; throw new NotSupportedException(); &#125;&#125; 接口的拓展（继承）： 12public interface IUndoable &#123; void Undo(); &#125;public interface IRedoable:IUndoable &#123; void Redo(); &#125; 显式的接口实现 实现多个接口的时候可能会造成成员签名的冲突。通过显式实现接口成员可以解决这个问题。 12345678910111213141516interface T1 &#123; void Foo(); &#125;interface T2 &#123; int Foo(); &#125;public class Widget:T1, T2&#123; public void Foo &#123; Console.WriteLine(&quot;Widget&#39;s implementation of T1.Foo&quot;); &#125; int T2.Foo &#123; Console.WriteLine(&quot;Widget&#39;s implementation of T2.Foo&quot;); return 1; &#125;&#125; 显式接口实现： 123456789101112131415161718192021222324252627282930313233343536using System;namespace ConsoleApp1&#123; public interface IFoo &#123; void Do(); &#125; public interface IBar &#123; int Do(); &#125; public class Parent : IFoo, IBar &#123; public void Do() &#x3D;&gt; Console.WriteLine(&quot;Foo&quot;); int IBar.Do() &#x2F;&#x2F; 显式的接口实现 &#123; Console.WriteLine(&quot;Bar&quot;); return 0; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Parent p &#x3D; new Parent(); p.Do(); &#x2F;&#x2F; Foo ((IBar)p).Do(); &#x2F;&#x2F; Bar 接口的显式实现 ((IFoo)p).Do(); &#x2F;&#x2F; Foo &#125; &#125;&#125; virtual的实现接口成员： 隐式实现的接口成员默认是sealed的 如果想要重写的话，必须在基类中把成员标记为virtual或者abstract 1234567891011public interface IUndoable &#123; void Undo(); &#125;public class TextBox : IUndoable &#x2F;&#x2F; 接口实现的类默认是sealed的&#123; public virtual void Undo() &#x3D;&gt; Console.WriteLine (&quot;TextBox.Undo&quot;);&#125;public class RichTextBox : TextBox &#x2F;&#x2F; 要重写就必须把基类的成员标记为virtual或者abstract&#123; public override void Undo() &#x3D;&gt; Console.WriteLine(&quot;RichTextBox.Undo&quot;);&#125; 在子类中重新实现接口： 子类可以重新实现父类已经实现的接口成员 1234567891011public interface IUndoable &#123; void Undo(); &#125;public class TextBox : IUndoable&#123; void IUndoable.Undo() &#x3D;&gt; Console.WriteLine(&quot;TextBox.Undo&quot;);&#125;public class RichTextBox : TextBox, IUndoable &#x2F;&#x2F; 重写&#123; public void Undo() &#x3D;&gt; Console.WriteLine(&quot;RichTextBox.Undo&quot;);&#125; 从接口调用重新实现的成员时，调用的是子类的实现 123RichTextBox r &#x3D; new RichTextBox();r.Undo; &#x2F;&#x2F; RichTextBox.Undo((IUndoable)r).Undo(); &#x2F;&#x2F; RichTextBox.Undo 此时已经被重写 假定RichTextBox定义不变，如果TextBox隐式实现Undo: 1234public class TextBox : IUndoable&#123; public void Undo() &#x3D;&gt; Console.WriteLine(&quot;TextBox.Undo&quot;);&#125; 那么就有了另外一种调用Undo方法 1234RichTextBox r &#x3D; new RichTextBox();r.Undo; &#x2F;&#x2F; RichTextBox.Undo((IUndoable)r).Undo(); &#x2F;&#x2F; RichTextBox.Undo((TextBox)r).Undo(); &#x2F;&#x2F; TextBox.Undo 接口与装箱： 把struct转化为接口会导致装箱 调用struct上隐式实现的成员不会导致装箱 1234567interface I &#123; void Foo(); &#125;struct S : I &#123; public void Foo() &#123;&#125; &#125;...S s &#x3D; new S();s.Foo(); &#x2F;&#x2F; No boxing 调用struct上隐式实现的成员不会导致装箱I i &#x3D; s; &#x2F;&#x2F; Box occurs struct转化为接口会导致装箱 枚举和嵌套类型 枚举一个特殊的值类型，可以指定一组命名的数值常量。 0,1,2,3会按照枚举成员的声明顺序自动赋值 也可以指定其他的类型作为枚举的整数类型，例如byte public enum BorderSide : byte { Left, Right, Top, Bottom } 也可以单独指定枚举成员对应的值 public enum BorderSide : byte { Left=1, Right=2, Top=10, Bottom=11 } 也可以指定集中某些成员的数值，未被赋值的成员将接着它前面已赋值成员的值递增 枚举类型转换： 枚举类型的实例可以与它对应的整数值相互显示转换： 12int i &#x3D; (int) BorderSide.Left;BorderSide side &#x3D; (BorderSide)i; 嵌套类型 嵌套类型是声明在另一个类型内部的类型。 可访问外层类型的私有成员，以及外层类所能访问的东西 可以使用所有的访问修饰符来声明 从外层累以外访问嵌套类型需要使用外层类名称进行限定（就像访问静态成员那样）","categories":[],"tags":[]},{"title":"设计模式（未完）","slug":"设计模式（未完）","date":"2020-06-29T03:58:50.845Z","updated":"2020-07-05T08:24:48.049Z","comments":true,"path":"2020/06/29/设计模式（未完）/","link":"","permalink":"http://yoursite.com/2020/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/","excerpt":"设计模式 单例模式 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。类的构造方法一定不能是public的 ，只能是private。这个实例是当前类的类成员变量，静态变量 12345678910111213public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton; //唯一类变量 private Singleton()&#123;&#125; //构造方法私有 public static Singleton getInstance()&#123; return null; &#125;&#125;","text":"设计模式 单例模式 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。类的构造方法一定不能是public的 ，只能是private。这个实例是当前类的类成员变量，静态变量 12345678910111213public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton; //唯一类变量 private Singleton()&#123;&#125; //构造方法私有 public static Singleton getInstance()&#123; return null; &#125;&#125; 单例模式的实例化时机分为饿汉式和懒汉式 1234567891011121314151617181920212223242526272829303132//饿汉式：在类加载的时候就进行实例化public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton = new Singleton(); //实例化 private Singleton()&#123;&#125; //构造方法私有 public static Singleton getInstance()&#123; return singleton;//返回singleton &#125;&#125;//懒汉式：在第一次使用的时候进行实例化public class SingletonPattern&#123; public static void main(String[] args)&#123; &#125;&#125;class Singleton&#123; private static Singleton singleton; private Singleton()&#123;&#125; //构造方法私有 public synchronized static Singleton getInstance()&#123; //加锁 if(singleton == null) singleton = new Singleton(); return singleton;//在第一次调用getInstance()方法时才进行实例化 &#125;&#125;","categories":[],"tags":[]},{"title":"vscode配置","slug":"vscode配置","date":"2020-06-28T12:23:48.182Z","updated":"2020-07-05T08:25:50.513Z","comments":true,"path":"2020/06/28/vscode配置/","link":"","permalink":"http://yoursite.com/2020/06/28/vscode%E9%85%8D%E7%BD%AE/","excerpt":"VSCode配置 更换主题 ctrl+shift+p 后输入Preferences Color Theme进行选择 图标主题 ctrl+shift+p 后输入Preferences File Icon Theme进行选择","text":"VSCode配置 更换主题 ctrl+shift+p 后输入Preferences Color Theme进行选择 图标主题 ctrl+shift+p 后输入Preferences File Icon Theme进行选择 生成构造函数 ctor 字号等设置 ctrl+， 自动保存 设置中 save搜索 在Auto Save选项中选择afterDelay 主命令框 F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下 Backspace 会进入到 Ctrl+P 模式 在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式 在 Ctrl+P 窗口下还可以: 直接输入文件名，跳转到文件 ? 列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol，也可以 Ctrl+T 常用快捷键 编辑器与窗口管理 打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 同时打开多个编辑器（查看多个文件） 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 切出一个新的编辑器（最多 3 个） Ctrl+\\，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名 左中右 3 个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+3 3 个编辑器之间循环切换 Ctrl+ 编辑器换位置， Ctrl+k然后按 Left或 Right 代码编辑 格式调整 代码行缩进 Ctrl+[ 、 Ctrl+] Ctrl+C 、 Ctrl+V 复制或剪切当前行/当前选中内容 代码格式化： Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code 上下移动一行： Alt+Up 或 Alt+Down 向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 在当前行下边插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 光标相关 移动到行首： Home 移动到行尾： End 移动到文件结尾： Ctrl+End 移动到文件开头： Ctrl+Home 移动到定义处： F12 定义处缩略图：只看一眼而不跳转过去 Alt+F12 移动到后半个括号： Ctrl+Shift+] 选择从光标到行尾： Shift+End 选择从行首到光标处： Shift+Home 删除光标右侧的所有字： Ctrl+Delete 扩展/缩小选取范围： Shift+Alt+Left 和 Shift+Alt+Right 多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 (在 sublime 中是删除当前行，后面自定义快键键中，设置与 Ctrl+Shift+K 互换了) 回退上一个光标操作： Ctrl+U 重构代码 找到所有的引用： Shift+F12 同时修改本文件中所有匹配的： Ctrl+F12 重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了 跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转 查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose 查找替换 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F 显示相关 全屏：F11 zoomIn/zoomOut：Ctrl +/- 侧边栏显/隐：Ctrl+B 显示资源管理器 Ctrl+Shift+E 显示搜索 Ctrl+Shift+F 显示 Git Ctrl+Shift+G 显示 Debug Ctrl+Shift+D 显示 Output Ctrl+Shift+U","categories":[],"tags":[]},{"title":"Java学习路线","slug":"Java学习路线","date":"2020-06-28T03:28:13.038Z","updated":"2020-06-29T06:30:30.403Z","comments":true,"path":"2020/06/28/Java学习路线/","link":"","permalink":"http://yoursite.com/2020/06/28/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"title：Java学习路线 测试字段","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-28T01:22:21.684Z","updated":"2020-07-05T08:08:27.414Z","comments":true,"path":"2020/06/28/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}