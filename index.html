<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon16x16.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon32x32.png?v=2.0.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Szwyz&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Szwyz&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Szwyz">
<meta name="twitter:card" content="summary"><meta name="keywords" content="Szwyz, Szwyz's Blog"><meta name="description" content=""><title>Szwyz's Blog</title><link ref="canonical" href="http://yoursite.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"dark","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Szwyz's Blog</div><div class="header-banner-info__subtitle">蚍蜉撼树</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/07/08/CSharp2%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/">C#进阶（未完）</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-07-08</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-07-08</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>[TOC]</p>

        <h2 id="泛型"   >
          <a href="#泛型" class="heading-link"><i class="fas fa-link"></i></a>泛型</h2>
      <p>C#中在不同的类型复用代码有两种方法：继承和泛型。泛型：使用了带有（类型）占位符的模板</p>
<p>泛型会声明类型参数-泛型的消费者需要提供类型参数（argument）来把占位符类型填充上</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Stack\&lt;T&gt; &#x2F;&#x2F; 可以在不同的类型间进行复用</span><br><span class="line">&#123;</span><br><span class="line">    int position;</span><br><span class="line">    T[] data &#x3D; new T[100];</span><br><span class="line">    public void Push (T obj) &#x3D;&gt; data[position++] &#x3D; obj;</span><br><span class="line">    public T Pop() &#x3D;&gt; data[--position];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var stack &#x3D; new Stack&lt;int&gt;();</span><br><span class="line">stack.Push(5);</span><br></pre></td></tr></table></div></figure>

<ul>
<li>Stack&lt;T&gt; Open Type（开放类型）</li>
<li>Stack&lt;int&gt; Closed Type（封闭类型）// 在运行时，所有的泛型类型实例都是封闭的</li>
</ul>

        <h3 id="泛型方法"   >
          <a href="#泛型方法" class="heading-link"><i class="fas fa-link"></i></a>泛型方法</h3>
      <p>泛型方法在方法的签名内也可以声明类型参数</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Swap&lt;T&gt;(ref T a,ref T b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp &#x3D; a;</span><br><span class="line">	a &#x3D; b;</span><br><span class="line">	b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int x &#x3D; 5;</span><br><span class="line">int y &#x3D; 10;</span><br><span class="line">Swap(ref x,ref y);</span><br></pre></td></tr></table></div></figure>


        <h3 id="声明类型参数"   >
          <a href="#声明类型参数" class="heading-link"><i class="fas fa-link"></i></a>声明类型参数</h3>
      <ul>
<li>在声明class、struct、interface、delegate的时候可以引入类型参数</li>
<li>其他的例如属性，就不可以引入类型参数，但是可以使用类型参数<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public struct Nullable&lt;T&gt; &#x2F;&#x2F; struct可以引用</span><br><span class="line">&#123;</span><br><span class="line">	public T Value &#123; get; &#125; &#x2F;&#x2F; 不可以引用，只可以使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
<p><strong>泛型类型/泛型方法可以有多个类型参数：</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Dictionary&lt;TKey,Tvalue&gt;&#123;...&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>泛型类型/泛型方法的名称可以被重载，条件是参数类型的个数不同</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">class A&lt;T&gt; &#123;&#125;</span><br><span class="line">class A&lt;T1,T2&gt; &#123;&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="typeof和未绑定泛型类型"   >
          <a href="#typeof和未绑定泛型类型" class="heading-link"><i class="fas fa-link"></i></a>typeof和未绑定泛型类型</h3>
      <ul>
<li>开放的泛型类型在编译后就变成了封闭的泛型类型</li>
<li>但是作为Type对象，那么未绑定的泛型类型在运行时是可以存在的。（只能通过typeof操作符来实现）</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A&lt;T&gt; &#123;&#125;</span><br><span class="line">class A&lt;T1,T2&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">Type a1 &#x3D; typeof(A&lt;&gt;); &#x2F;&#x2F; 表示A&lt;T&gt;</span><br><span class="line">Type a2 &#x3D; typeof(A&lt;,&gt;); &#x2F;&#x2F; 对应A&lt;T1,T2&gt;</span><br></pre></td></tr></table></div></figure>

<p><strong>泛型的默认值：</strong>default关键字可以用于获取泛型类型参数的默认值。 array[i] = default(T)</p>

        <h3 id="泛型约束"   >
          <a href="#泛型约束" class="heading-link"><i class="fas fa-link"></i></a>泛型约束</h3>
      <ul>
<li>默认情况下，泛型的类型参数可以是任何类型的。</li>
<li>如果只允许使用特定的类型参数，就可以指定约束<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">where T:base-class &#x2F;&#x2F; T必须是某个父类的子类</span><br><span class="line">where T:interface &#x2F;&#x2F; T必须实现了某个接口</span><br><span class="line">where T:class &#x2F;&#x2F; T必须是引用类型</span><br><span class="line">where T:struct &#x2F;&#x2F; T是值类型（不包括可空值类型）</span><br><span class="line">where T:new() &#x2F;&#x2F; 里面必须有一个无参的构造函数</span><br><span class="line">where U:T &#x2F;&#x2F; 要求类型参数U继承类型参数T</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p><strong>裸类型约束：</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	Stack&lt;U&gt; FilteredStack&lt;U&gt;() where U : T&#123;...&#125;</span><br><span class="line">	&#x2F;&#x2F; 泛型方法FilteredStack有一个泛型参数U，要求U必须继承自T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="泛型类型的子类"   >
          <a href="#泛型类型的子类" class="heading-link"><i class="fas fa-link"></i></a>泛型类型的子类</h3>
      <ul>
<li>泛型class可以有子类，在子类里，可以继续让父类的类型参数保持开放</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;T&gt; &#123;&#125;</span><br><span class="line">class SpecialStack&lt;T&gt; : Stack&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>在子类里，也可以使用具体的类型来关闭（封闭）父类的类型参数   </li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class IntStack : Stack&lt;int&gt; &#123;&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>子类型也可以引入新的类型参数                                                                                                                                                                          </li>
</ul>

        <h3 id="自引用的泛型声明"   >
          <a href="#自引用的泛型声明" class="heading-link"><i class="fas fa-link"></i></a>自引用的泛型声明</h3>
      <ul>
<li>在封闭类型参数的时候，该类型可以把它自己作为具体的类型</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface IEquatable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    bool Equals (T obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Balloon : IEquatable&lt;Balloon&gt; &#x2F;&#x2F; 泛型参数T使用的就是Ballon</span><br><span class="line">&#123;</span><br><span class="line">    public string Color &#123;get; set; &#125;</span><br><span class="line">    public int CC &#123; get; set; &#125;</span><br><span class="line">    </span><br><span class="line">    public bool Equals (Ballon b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b &#x3D;&#x3D; null) return false;</span><br><span class="line">        return b.Color &#x3D;&#x3D; Color &amp;&amp;b.CC &#x3D;&#x3D; CC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>静态数据：</strong>针对每一个封闭类型，静态数据是唯一的</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Bob&lt;T&gt; &#123; public static int Count;&#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(++Bob&lt;int&gt;.Count); &#x2F;&#x2F; 1</span><br><span class="line">        Console.WriteLine(++Bob&lt;int&gt;.Count); &#x2F;&#x2F; 2</span><br><span class="line">        Console.WriteLine(++Bob&lt;string&gt;.Count); &#x2F;&#x2F; 1</span><br><span class="line">        Console.WriteLine(++Bob&lt;object&gt;.Count); &#x2F;&#x2F; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="类型参数和转换"   >
          <a href="#类型参数和转换" class="heading-link"><i class="fas fa-link"></i></a>类型参数和转换</h3>
      <ul>
<li>C#转换操作符支持下列转换：<ul>
<li>数值转换</li>
<li>引用转换</li>
<li>装箱拆箱转换</li>
<li>自定义转换</li>
</ul>
</li>
<li>决定采用的是哪种转换，发生在编译时，根据已知类型的操作数来决定</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder Foo&lt;T&gt; (T arg)</span><br><span class="line">&#123;</span><br><span class="line">	if (arg is StringBuilder )</span><br><span class="line">        return (StringBuilder )arg; &#x2F;&#x2F; will not compile</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 不知道T的具体类型，编译器可能认为做的自定义转换 使用as操作符</span><br><span class="line"></span><br><span class="line">StringBuilder Foo&lt;T&gt; (T arg)</span><br><span class="line">&#123;</span><br><span class="line">	StringBuilder sb &#x3D; arg as StringBuilder;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 更加一般的做法</span><br><span class="line">return (StringBuilder)(object)arg;</span><br></pre></td></tr></table></div></figure>

<p><strong>拆箱转换也可能导致二义性。</strong>例如以下代码可能是拆箱转换、数制转换或者自定义转换</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int Foo&lt;T&gt; (T x) &#x3D;&gt; (int)x; &#x2F;&#x2F; Compile-time error</span><br><span class="line"></span><br><span class="line">int Foo&lt;T&gt; (T x) &#x3D;&gt; (int)(object)x; &#x2F;&#x2F; 解决办法</span><br></pre></td></tr></table></div></figure>


        <h3 id="协变（未完）"   >
          <a href="#协变（未完）" class="heading-link"><i class="fas fa-link"></i></a>协变（未完）</h3>
      
        <h3 id="逆变（未完）"   >
          <a href="#逆变（未完）" class="heading-link"><i class="fas fa-link"></i></a>逆变（未完）</h3>
      
        <h3 id="不变（未完）"   >
          <a href="#不变（未完）" class="heading-link"><i class="fas fa-link"></i></a>不变（未完）</h3>
      
        <h3 id="C-泛型和C-模板对比"   >
          <a href="#C-泛型和C-模板对比" class="heading-link"><i class="fas fa-link"></i></a>C#泛型和C++模板对比</h3>
      <p>C#的泛型和C++的模板在应用上很相似，但是它们的工作原理却大不相同。两者都发生了生产者和消费者的关联，且生产者的占位符将被消费者填充。但是在C#泛型中，生产者的类型(开放类型如List&lt;T&gt;)可以编译到程序库中(如mscorlib.dII) 。这是因为生产者和消费者进行关联生成封闭类型是在运行时发生的。而C++模板中，这一关联是在编译时进行的。这意味着C++不能将模板库部署为. dll,它们只存在于源代码中。这令动态语法检查难以实现，更不用说即时创建或参数化类型了。</p>
<p>为了深究这一情形形成的原因，我们重新观察C#的Max方法：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static T Max &lt;T&gt; (T a, T b) where T: IComparable&lt;T&gt; &#x3D;&gt; a.CompareTo(b) &gt;0 ? a:b ;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;但是以下是错误的</span><br><span class="line">static T Max &lt;T&gt; (T a ,T b) &#x3D;&gt; (a&gt;b?a:b); &#x2F;&#x2F; Compile error</span><br></pre></td></tr></table></div></figure>

<p>原因是，Max需要在编译时支持所有可能的T类型值。由于对于任意类型T，运算符&gt;没有统一的含义，因此上述程序无法通过编译。实际上，并不是所有的类型都支持&gt;运算符。相对的，下面的代码是用C++的模板编写的Max方法。而该代码会为每一个T值分别编译。对特定T呈现的不同的&gt;语义，而当T不支持&gt;运算符的时候，编译失败：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">MAX</span> (<span class="title">T</span> <span class="title">a</span>,<span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h2 id="C-的高级特性"   >
          <a href="#C-的高级特性" class="heading-link"><i class="fas fa-link"></i></a>C#的高级特性</h2>
      
        <h3 id="委托"   >
          <a href="#委托" class="heading-link"><i class="fas fa-link"></i></a>委托</h3>
      <p>委托是一个对象，它知道如何调用一个方法。</p>
<p>委托类型定义了委托实例可以调用的那类方法，具体来说，委托类型定义了方法的返回类型和参数。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delegate int Transformer(int x);</span><br><span class="line">&#x2F;&#x2F; Transformer兼容任何返回类型为int并有一个int类型的参数的方法,比如如下方法</span><br><span class="line">static int Square(int x) &#x3D;&gt; x*x;</span><br></pre></td></tr></table></div></figure>


        <h4 id="委托实例"   >
          <a href="#委托实例" class="heading-link"><i class="fas fa-link"></i></a>委托实例</h4>
      <p>把方法赋值给委托变量的时候就创建了委托实例</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transformer t &#x3D; Square;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">int answer &#x3D; t(3); &#x2F;&#x2F; 9</span><br></pre></td></tr></table></div></figure>

<p>委托实例其实就是调用者的委托：调用者调用委托，然后委托调用目标方法。这样间接的把调用者和目标方法解耦了。</p>
<p><strong>简写：</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer t &#x3D; Square; &#x2F;&#x2F; 简写</span><br><span class="line">Transformer t &#x3D; new Transformer(Square);</span><br><span class="line"></span><br><span class="line">t(3); &#x2F;&#x2F; 简写</span><br><span class="line">t.Invoke(3);</span><br></pre></td></tr></table></div></figure>


        <h4 id="编写插件式的方法"   >
          <a href="#编写插件式的方法" class="heading-link"><i class="fas fa-link"></i></a>编写插件式的方法</h4>
      <ul>
<li>方法是运行时才赋值给委托变量的</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public delegate int Transformer(int x);</span><br><span class="line"></span><br><span class="line">class Util</span><br><span class="line">&#123;</span><br><span class="line">    public static void Transform(int[] values, Transformer t)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; values.Length; i++)</span><br><span class="line">            values[i] &#x3D; t(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        int[] values &#x3D; &#123; 1, 2, 3 &#125;;</span><br><span class="line">        Util.Transform(values, Square);</span><br><span class="line"></span><br><span class="line">        foreach (int i in values)</span><br><span class="line">            Console.WriteLine(i + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int Square(int x) &#x3D;&gt; x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="多播委托"   >
          <a href="#多播委托" class="heading-link"><i class="fas fa-link"></i></a>多播委托</h4>
      <p>所有委托实例都具有多播的能力。一个委托实例可以引用一组目标方法。</p>
<p>使用+=操作符可以合并委托实例：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用d就会调用SomeMethod1和SomeMethod2</span><br><span class="line">&#x2F;&#x2F; 委托的调用顺序与它们的定义顺序一致</span><br><span class="line">SomeDelegate d &#x3D; SomeMethod1;</span><br><span class="line">d +&#x3D; SomeMethod2;</span><br></pre></td></tr></table></div></figure>

<p>使用-=操作符会把右边的委托从左边的委托里移除</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d -&#x3D; SomeMethod1;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>委托是不可变的</li>
<li>使用+=或-=时，实质是创建一个新的委托实例，并把它赋值给已有变量</li>
</ul>
<p>如果一个多播委托拥有非void的返回类型，则调用者将从最后一个触发的方法接收返回值。前面的方法仍然调用，但是返回值都会被丢弃。大部分调用多播委托的情况都会返回void类型，因此这个细小的差异就没有了。</p>

        <h4 id="实例方法目标和静态方法目标"   >
          <a href="#实例方法目标和静态方法目标" class="heading-link"><i class="fas fa-link"></i></a>实例方法目标和静态方法目标</h4>
      <ul>
<li>当一个实例方法被赋值给委托对象的时候，这个委托对象不仅要保留对方法的引用，还要保留着方法所属实例的引用</li>
<li>System.Delegate的Target属性就代表着这个实例</li>
<li>如果引用的是静态方法，那么Target属性的值就是null</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">namespace Demo</span><br><span class="line">&#123;</span><br><span class="line">    public delegate void ProgressReporter(int percentComplete);</span><br><span class="line"></span><br><span class="line">    class X</span><br><span class="line">    &#123;</span><br><span class="line">        public void InstanceProgress(int percentComplete)</span><br><span class="line">        &#x3D;&gt; Console.WriteLine(percentComplete);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            X x &#x3D; new X();</span><br><span class="line">            ProgressReporter p &#x3D; x.InstanceProgress;</span><br><span class="line">            p(99);</span><br><span class="line">            Console.WriteLine(p.Target &#x3D;&#x3D; x); &#x2F;&#x2F; True</span><br><span class="line">            Console.WriteLine(p.Method); &#x2F;&#x2F; Void InstanceProgress(Int32) 表示这个方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="泛型委托类型"   >
          <a href="#泛型委托类型" class="heading-link"><i class="fas fa-link"></i></a>泛型委托类型</h4>
      <p>委托类型可以包含泛型类型参数</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">namespace Demo</span><br><span class="line">&#123;</span><br><span class="line">    public delegate T Transformer&lt;T&gt;(T arg); &#x2F;&#x2F; 返回类型T</span><br><span class="line"></span><br><span class="line">    public class Util</span><br><span class="line">    &#123;</span><br><span class="line">        public static void Transform&lt;T&gt;(T[] values, Transformer&lt;T&gt; t) &#x2F;&#x2F; 泛型方法</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; values.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                values[i] &#x3D; t(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class Test</span><br><span class="line">        &#123;</span><br><span class="line">            static void Main()</span><br><span class="line">            &#123;</span><br><span class="line">                int[] values &#x3D; &#123; 1, 2, 3 &#125;;</span><br><span class="line">                Util.Transform(values, Square);</span><br><span class="line">                foreach (int i in values)</span><br><span class="line">                    Console.Write(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            static int Square(int x) &#x3D;&gt; x * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="Func和Action委托（未完）"   >
          <a href="#Func和Action委托（未完）" class="heading-link"><i class="fas fa-link"></i></a>Func和Action委托（未完）</h4>
      <p>使用泛型委托，就可以写出这样一组委托类型，它们可调用的方法可以拥有任意的返回类型和任意（合理）数量的参数。</p>

        <h4 id="委托vs接口"   >
          <a href="#委托vs接口" class="heading-link"><i class="fas fa-link"></i></a>委托vs接口</h4>
      <ul>
<li>委托可以解决的问题，接口都可以解决</li>
<li>在以下之一情况下，更适合使用委托：<ul>
<li>接口只能定义一个方法</li>
<li>需要多播能力</li>
<li>订阅者需要多次实现接口</li>
</ul>
</li>
</ul>

        <h4 id="委托类型的兼容性"   >
          <a href="#委托类型的兼容性" class="heading-link"><i class="fas fa-link"></i></a>委托类型的兼容性</h4>
      <p>委托类型之间互不相容，即使方法签名一样</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delegate void D1();</span><br><span class="line">delegate void D2();</span><br><span class="line"></span><br><span class="line">D1 d1 &#x3D; Method1;</span><br><span class="line">D2 d2 &#x3D; d1; &#x2F;&#x2F; Compile-time error</span><br></pre></td></tr></table></div></figure>

<p>如果委托实例指向相同的目标方法，则认为它们是等价的，如果多播委托按照相同的顺序引用相同的方法，则认为它们是等价的。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delegate void D();</span><br><span class="line">...</span><br><span class="line">D d1 &#x3D; Method1;</span><br><span class="line">D d2 &#x3D; Method2;</span><br><span class="line">Console.WriteLine(d1 &#x3D;&#x3D; d2); &#x2F;&#x2F; true</span><br></pre></td></tr></table></div></figure>

<p>调用方法时，你可以得到一个比请求的类型更具体的类型的返回结果。而委托的目标方法可以返回比委托描述里更具体的类型的返回结果，Covariance.</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">namespace Demo</span><br><span class="line">&#123;</span><br><span class="line">    delegate object ObjectRetriever();</span><br><span class="line"></span><br><span class="line">    class Test</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            ObjectRetriever o &#x3D; new ObjectRetriever(RetrieveString);</span><br><span class="line">            object result &#x3D; o();</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">        &#125;</span><br><span class="line">        static string RetrieveString() &#x3D;&gt; &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="事件"   >
          <a href="#事件" class="heading-link"><i class="fas fa-link"></i></a>事件</h3>
      <p>使用委托的时候，通常会出现两个角色：广播者和订阅者</p>
<p>广播者包含一个委托字段，广播者通过调用委托爱决定什么时候进行广播</p>
<p>定于这是方法目标的接受者，订阅者可以决定何时开始或结束监听，方式是通过在委托上调用+=和-=</p>
<p><strong>事件</strong>就是将上述模式正式化的一个语言特性。事件是一种结构，为了实现广播者/订阅者模型，它只暴露了所需的委托特性的部分子集。事件的主要目的就是防止订阅者之间相互干扰。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public delegate void PriceChangedHandler(decimal oldPrice,decimal newPrice);</span><br><span class="line"></span><br><span class="line">public class Broadcaster</span><br><span class="line">&#123;</span><br><span class="line">    public event PriceChangeHandler PriceChanged; &#x2F;&#x2F; 声明一个事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>注意：</strong>在类的内外是区别对待的。Broadercaster类型里面的代码拥有对PriceChanged的完全访问权，在这里就把它当做委托。而Broadercaster类型以外的代码只能对PriceChanged这个事件执行 +=和-=操作。</p>

        <h4 id="标准的事件模式（未完）"   >
          <a href="#标准的事件模式（未完）" class="heading-link"><i class="fas fa-link"></i></a>标准的事件模式（未完）</h4>
      <ul>
<li>为编写事件，.NET定义了一个标准的模式</li>
<li>System.EventArgs，一个预定义的框架类，除了静态的Empty属性外，没有其他成员</li>
<li>EventArgs是为事件传递信息的类的基类</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PriceChangedEventArgs : System.EventArgs</span><br><span class="line">&#123;</span><br><span class="line">    public readonly decimal LastPrice;</span><br><span class="line">    public readonly decimal NewPrice;</span><br><span class="line">    </span><br><span class="line">    public PriceChangedEventArgs (decimal lastPrice,decimal newPrice)</span><br><span class="line">    &#123;</span><br><span class="line">        LastPrice &#x3D; lastPrice;</span><br><span class="line">        NewPrice &#x3D; newPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>EventArgs子类就位后，下一步就是选择或者定义事件的委托。必须遵循三条规则：</p>
<ul>
<li>返回类型是void</li>
<li>接受两个参数，第一个参数类型是object，第二个参数类型是EventArgs的子类。第一个参数表示时间的广播者，第二个参数包含需要传递的信息。</li>
<li>委托的名称必须以EventHandler结尾  </li>
</ul>
<p>框架定义了一个名为System.EventHadnler&lt;&gt;的泛型委托，该委托满足以上的三个条件：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public delegate void EventHandler&lt;TEventArgs&gt;</span><br><span class="line">    (object source,TEventArgs e)where TEventArgs : EventArgs;</span><br></pre></td></tr></table></div></figure>

<p>接下来是定义选定委托类型的事件：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Stock</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="Lambda表达式"   >
          <a href="#Lambda表达式" class="heading-link"><i class="fas fa-link"></i></a>Lambda表达式</h3>
      <p>Lambda表达式是一种可以替代委托实例的匿名方法。编译器会立即将Lambda表达式转换为以下两种形式之- :</p>
<ul>
<li>一个委托实例。</li>
<li>一个类型为Expression&lt;TDelegate&gt;的表达式树。 该表达式树将Lambda表达式内部的代码表现为一个可遍历的对象模型，因此Lambda表达式的解释可以延迟到运行时。</li>
</ul>
<p>下面的委托类型：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delegate int Transformer(int i);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可使用Lambda表达式x&#x3D;&gt;x*x赋值，也可以调用该表达式</span><br><span class="line">Transformer sqr &#x3D; x &#x3D;&gt; x*x;</span><br><span class="line">Consonle.WriteLine(sqr(3)); &#x2F;&#x2F; 9</span><br></pre></td></tr></table></div></figure>

<p>实际上，编译器会通过编写一个私有方法来解析这个lambda表达式，然后把表达式移动到这个方法里。</p>
<p><strong>Lambda表达式的形式:</strong></p>
<p>（参数） =&gt; 表达式或语句块  // 如果只有一个参数并且类型可推断的话，那么参数的小括号可以省略</p>
<ul>
<li>Lambda表达式通常和与Func和Action委托一起使用</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;string,string,int&gt; totalLength &#x3D; (s1,s2) &#x3D;&gt; s1.Length + s2.Length;</span><br><span class="line">int total &#x3D; totalLength(&quot;hello&quot;,&quot;world&quot;); &#x2F;&#x2F; 10</span><br></pre></td></tr></table></div></figure>


        <h4 id="显式指定Lambda表达式的参数类型"   >
          <a href="#显式指定Lambda表达式的参数类型" class="heading-link"><i class="fas fa-link"></i></a>显式指定Lambda表达式的参数类型</h4>
      <p>当编译器无法推断Lambda表达式的参数类型时，就需要显式的指定Lambda表达式的参数类型</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Foo&lt;T&gt; (T x) &#123;&#125;</span><br><span class="line">void Bar&lt;T&gt; (Action&lt;T&gt; a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下代码无法通过编译，因为编译器无法推断x的类型</span><br><span class="line">Bar(x &#x3D;&gt; Foo(X));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以通过显式指定x的类型来修正这个问题</span><br><span class="line">Bar((int x) &#x3D;&gt; Foo(x));</span><br><span class="line">&#x2F;&#x2F; 也可以指定泛型类型参数的类型</span><br><span class="line">Bar&lt;int&gt; (x&#x3D;&gt; Foo(x));</span><br></pre></td></tr></table></div></figure>


        <h4 id="捕获外部变量"   >
          <a href="#捕获外部变量" class="heading-link"><i class="fas fa-link"></i></a>捕获外部变量</h4>
      <p>lambda表达式可以引用本地的变量和所在方法的参数</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    int factor &#x3D; 2;</span><br><span class="line">    Func&lt;int,int&gt; multiplier &#x3D; n&#x3D;&gt; n * factor;</span><br><span class="line">    Console.WriteLine(multiplier(3)); &#x2F;&#x2F; 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>被捕获的变量：</p>
<ul>
<li>被Lambda表达式引用的外部变量叫做被捕获的变量（captured variables)</li>
<li>捕获了外部变量的lambda表达式叫做闭包</li>
<li>被捕获的变量是在委托被实际调用的时候才被计算，而不是在捕获的时候</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int factor &#x3D; 2;</span><br><span class="line">Func&lt;int,int&gt; multiplier &#x3D; n &#x3D;&gt; n * factor ;</span><br><span class="line">factor &#x3D; 10;</span><br><span class="line">Console.WriteLine(multiplier(3)); &#x2F;&#x2F; 30</span><br></pre></td></tr></table></div></figure>

<p>Lambda表达式本身也可以更新被捕获的变量</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int seed &#x3D; 0;</span><br><span class="line">Func&lt;int&gt; natural &#x3D; () &#x3D;&gt; seed++; &#x2F;&#x2F; 没有参数所以（）</span><br><span class="line">Concole.WrieteLine(natural()); &#x2F;&#x2F; 0</span><br><span class="line">Concole.WrieteLine(natural()); &#x2F;&#x2F; 1</span><br><span class="line">Concole.WrieteLine(seed); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></div></figure>

<p>被捕获的变量的声明周期会被延长到和委托一样</p>

        <h4 id="Lambda表达式内的本地变量"   >
          <a href="#Lambda表达式内的本地变量" class="heading-link"><i class="fas fa-link"></i></a>Lambda表达式内的本地变量</h4>
      <p>在Lambda表达式内实例化的本地变量对于委托实例的每次调用来说都是唯一的。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static Func&lt;int&gt; Natural()</span><br><span class="line">&#123;</span><br><span class="line">    return() &#x3D;&gt; &#123;int seed &#x3D; 0; return seed++; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    Func&lt;int&gt; natural &#x3D; Natural();</span><br><span class="line">    Console.WriteLine(natural()); &#x2F;&#x2F; 0</span><br><span class="line">    Console.WriteLine(natural()); &#x2F;&#x2F; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="捕获迭代变量"   >
          <a href="#捕获迭代变量" class="heading-link"><i class="fas fa-link"></i></a>捕获迭代变量</h4>
      <p>当捕获for循环的迭代变量时，C#会把这个变量当做是在循环外部定义的变量，这就意味着每次迭代捕获的都是同一个变量</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Action[] actions &#x3D; new Action[3]; &#x2F;&#x2F; Action数组 可以容纳三个委托</span><br><span class="line"></span><br><span class="line">for (int i &#x3D;0; i &lt; 3; i++)</span><br><span class="line">    actions[i] &#x3D; () &#x3D;&gt; Console.Write(i); &#x2F;&#x2F; 把输出这个Lambda表达式赋值给action委托</span><br><span class="line"></span><br><span class="line">foreach(Action a in actions) a(); &#x2F;&#x2F; 333 循环委托数组</span><br></pre></td></tr></table></div></figure>

<p>如何解决？</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Action[] actions &#x3D; new Action[3]; &#x2F;&#x2F; Action数组 可以容纳三个委托</span><br><span class="line">for (int i &#x3D;0; i &lt; 3; i++)</span><br><span class="line">&#123;</span><br><span class="line">	int loopScopedi &#x3D; i; </span><br><span class="line">    actions[i] &#x3D; () &#x3D;&gt; Console.Write(loopScopedi); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foreach(Action a in actions) a(); &#x2F;&#x2F; 012</span><br></pre></td></tr></table></div></figure>


        <h4 id="Lambda表达式和本地方法"   >
          <a href="#Lambda表达式和本地方法" class="heading-link"><i class="fas fa-link"></i></a>Lambda表达式和本地方法</h4>
      <p>本地方法是C#7的一个新特性。它和L ambda表达式在功能上有很多重复之处，但它有三个优点:</p>
<ul>
<li>可以简单明了的进行递归</li>
<li>无需指定委托类型</li>
<li>性能开销略低一点</li>
</ul>
<p>本地方法效率更高是因为它避兔了委托的间接调用(需要CPU周期,内存分配)。本地方法也可以访问所在方法的本地变量，而且无需编译器把被捕获的变量hoist到隐藏的类。</p>

        <h3 id="Try语句和异常"   >
          <a href="#Try语句和异常" class="heading-link"><i class="fas fa-link"></i></a>Try语句和异常</h3>
      
        <h4 id="catch"   >
          <a href="#catch" class="heading-link"><i class="fas fa-link"></i></a>catch</h4>
      <ul>
<li>catch块可以访问一个Exception对象，这个Exception对象里含有关于错误的信息</li>
<li>catch块通常被用来对错误进行处理/补偿或者重新抛出异常</li>
</ul>
<p>可以把异常类型和变量都拿掉，这就代表着会捕获所有的异常</p>
<p>catch {…..}</p>

        <h4 id="finally"   >
          <a href="#finally" class="heading-link"><i class="fas fa-link"></i></a>finally</h4>
      <p>finall块为程序增加了确定性:：CLR总是尽力去执行它。它通常用来做一些清理任务。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	... &#x2F;&#x2F; 可能发生异常错误的代码</span><br><span class="line">&#125;</span><br><span class="line">catch (ExceptionA ex) &#x2F;&#x2F; 每个catch捕获一个特定异常</span><br><span class="line">&#123;</span><br><span class="line">	... &#x2F;&#x2F; handle exception of type ExceptionA</span><br><span class="line">&#125;</span><br><span class="line">catch (ExceptionB ex)</span><br><span class="line">&#123;</span><br><span class="line">		... &#x2F;&#x2F; handle exception of type ExceptionB</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">... &#x2F;&#x2F; cleanup code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="异常的过滤"   >
          <a href="#异常的过滤" class="heading-link"><i class="fas fa-link"></i></a>异常的过滤</h4>
      <p>从C#6开始，可以在catch子句中添加一个when子句来指定一个异常过滤器</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch (WebException ex) when (ex.Status &#x3D;&#x3D; WebExceptionStatus.Timeout)</span><br><span class="line">&#123;</span><br><span class="line">    ... &#x2F;&#x2F;当when后面的布尔表达式true时才会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="抛出异常"   >
          <a href="#抛出异常" class="heading-link"><i class="fas fa-link"></i></a>抛出异常</h4>
      <p>异常可以被运行时或者用户抛出</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">	static void Display (string name )</span><br><span class="line">	&#123;</span><br><span class="line">		if (nane &#x3D;&#x3D; null)</span><br><span class="line">			throw new ArgunentNullException (naneof (nane)) ;&#x2F;&#x2F;用户抛出的异常</span><br><span class="line">		Console .WriteLine (name );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	static void Main()</span><br><span class="line">	&#123;</span><br><span class="line">		try &#123; Display (null); &#125;</span><br><span class="line">		catch (ArgumentNullException ex)</span><br><span class="line">    	&#123;</span><br><span class="line">        	Console .WriteLine (&quot;Caught the exception&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>C# 7之前，throw是个语句。而现在它可以作为expression-bodied functions里的一个表达式:<br>public string Foo() =&gt; throw new NotImplementedException();</p>
<p><strong>重新抛出异常：</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;...&#125;</span><br><span class="line">catch (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">	 &#x2F;&#x2F; Log error</span><br><span class="line">	...</span><br><span class="line">	throw; &#x2F;&#x2F; Rethrow same exception</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果使用throw ex代替throw的话，程序仍可运行，但是新传递的异常的Stacktrace属性就不会反应原始错误了。</p>

        <h4 id="System-Exception的关键属性"   >
          <a href="#System-Exception的关键属性" class="heading-link"><i class="fas fa-link"></i></a>System.Exception的关键属性</h4>
      <ul>
<li>StackTrace 它是一个字符串，展现了从异常发生地到catch块所有被调用的方法</li>
<li>Message 关于错误的描述信息</li>
<li>InnerException 引起外层异常的内层异常(如果存在的话)。而且InnerException本身还有可能含有InnerException</li>
</ul>

        <h3 id="枚举和迭代器"   >
          <a href="#枚举和迭代器" class="heading-link"><i class="fas fa-link"></i></a>枚举和迭代器</h3>
      
        <h4 id="枚举"   >
          <a href="#枚举" class="heading-link"><i class="fas fa-link"></i></a>枚举</h4>
      <ul>
<li>枚举器是一个只读的，作用于一序列值的、只能向前的游标。</li>
<li>枚举器是一个实现了下列任意-个接口的对象<ul>
<li>System.Collections.lEnumerator</li>
<li>System.Collections.Generic .IEnumerator&lt;T&gt;</li>
</ul>
</li>
<li>技术上来说，任何一一个含有名为MoveNext方法和名为Current的属性的对象，都会<br>被当作枚举器来对待。</li>
<li>foreach语句会迭代可枚举的对象(enumerable object)。可枚举的对象是一序列值的逻辑表示。它本身不是游标，它是一个可以基于本身产生游标的对象。</li>
</ul>

        <h5 id="可枚举对象"   >
          <a href="#可枚举对象" class="heading-link"><i class="fas fa-link"></i></a>可枚举对象</h5>
      <ul>
<li>一个可枚举对象可以是(下列任意一个)：<ul>
<li>实现了IEnumerable或者IEnumerable&lt;T&gt;的对象。</li>
<li>有一个名为GetEnumerator的方法，并且该方法返回一个枚举器(enumerator)</li>
</ul>
</li>
<li>lEnumerator和lEnumerable是定义在System.Collections命名空间下的。</li>
<li>lEnumerator&lt;T&gt;和lEnumerable&lt;T&gt;是定义在System.Collections.Generic命名空间下的。</li>
</ul>

        <h5 id="枚举模式"   >
          <a href="#枚举模式" class="heading-link"><i class="fas fa-link"></i></a>枚举模式</h5>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Enumerator &#x2F;&#x2F; 枚举器 通常实现了IEnumerator或者Inumerator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public IteratorVariableType Current&#123; get&#123;...&#125;&#125;</span><br><span class="line">    public bool MoveNext() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Enumerable &#x2F;&#x2F; 可枚举的对象 通常实现了IEnumerable或者Inumerable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public Enumerator GetEnumerator() &#123;...&#125; &#x2F;&#x2F; 返回一个Enumerator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>示例：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foreach (char C in &quot;beer&quot;)</span><br><span class="line">	Console.WriteLine (C);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using (var enumerator &#x3D; &quot;beer&quot;.GetEnumerator())</span><br><span class="line">	while ( enumerator.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">	var element &#x3D; enumerator.Current;</span><br><span class="line">	Console .WriteLine (element);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="集合初始化器"   >
          <a href="#集合初始化器" class="heading-link"><i class="fas fa-link"></i></a>集合初始化器</h5>
      <p>只需一步就可以把可枚举对象进行实例化并且填充里面的元素：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">List&lt;int&gt; list &#x3D; new List&lt;int&gt;&#123;1,2,3&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 但是编译器会把它翻译成</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">List&lt;int&gt; list &#x3D; new List&lt;int&gt;();</span><br><span class="line">list.Add(1);</span><br><span class="line">list.Add(2);</span><br><span class="line">list.Add(3);</span><br></pre></td></tr></table></div></figure>


        <h4 id="迭代器Iterators（未完）"   >
          <a href="#迭代器Iterators（未完）" class="heading-link"><i class="fas fa-link"></i></a>迭代器Iterators（未完）</h4>
      <p>foreach语句是枚举器(enumerator) 的消费者，而迭代器(iterator) 是枚举器的生产者。</p>

        <h3 id="拓展方法"   >
          <a href="#拓展方法" class="heading-link"><i class="fas fa-link"></i></a>拓展方法</h3>
      <ul>
<li>扩展方法允许我们使用新的方法来扩展现有的类型,而且无需修改原有类型的定义.</li>
<li>扩展方法是静态类的一个静态方法，在静态方法里的第一个参数使用this修饰符， 第一<br>个参数的类型就是要被扩展的类型.</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static class StringHelper</span><br><span class="line">&#123;</span><br><span class="line">    public static bool IsCapitalized(this string s) &#x2F;&#x2F; 扩展了string</span><br><span class="line">    &#123;</span><br><span class="line">        if (string.IsNullOrEmpty(s)) return false;</span><br><span class="line">        return char.IsUpper(s[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里的IsCapitalized方法可以这样调用</span><br><span class="line">Console. Writeline (StringHelper.IsCapitalized (&quot;Perth&quot;));</span><br><span class="line">Console . WriteLine (&quot;Perth&quot;.IsCapitalized());</span><br></pre></td></tr></table></div></figure>

<p><strong>拓展方法的实现原理：</strong>拓展方法的这种调用方式实际上是这样被编译的</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arg0.Method (arg1, arg2,…); &#x2F;&#x2F; Extension method call</span><br><span class="line">StaticClass.Method (arg0， arg1， arg2， ...); &#x2F;&#x2F; Static nethod call</span><br></pre></td></tr></table></div></figure>


        <h4 id="歧义和解析命名空间"   >
          <a href="#歧义和解析命名空间" class="heading-link"><i class="fas fa-link"></i></a>歧义和解析命名空间</h4>
      <p>只有所在类处于在作用范围内的拓展方法才可以被访问，典型的做法是引入命名空间</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace MyApp</span><br><span class="line">&#123;</span><br><span class="line">    using Utils;</span><br><span class="line">    class Test</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main() &#x3D;&gt; Console.WriteLine(&quot;Perth&quot;.IsCapitalized());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="拓展方法和实例方法"   >
          <a href="#拓展方法和实例方法" class="heading-link"><i class="fas fa-link"></i></a>拓展方法和实例方法</h4>
      <p>任何兼容的实例方法的优先级总是高于扩展方法。在下面的例子中，即使参数x类型为int也会优先调用Test的Fo方法：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    public void Foo(objectx) &#123; &#125; &#x2F;&#x2F; This method always wins</span><br><span class="line">&#125;</span><br><span class="line">static class Extensions</span><br><span class="line">&#123;</span><br><span class="line">    public static void Foo(this Testt, intx) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>只能通过普通的静态调用来调用拓展方法：Extensions.Foo()；</p>

        <h4 id="拓展方法和拓展方法"   >
          <a href="#拓展方法和拓展方法" class="heading-link"><i class="fas fa-link"></i></a>拓展方法和拓展方法</h4>
      <p>如果两个扩展方法签名相同，则扩展方法必须作为一个普通的静态方法调用才能进行区分。当然，如果其中一个扩展方法具有更具体的参数，那么更具体参数的方法优先级更高。</p>

        <h3 id="匿名类型"   >
          <a href="#匿名类型" class="heading-link"><i class="fas fa-link"></i></a>匿名类型</h3>
      <ul>
<li>匿名类型就是有编译器即时创建的一个class,它用来存储一组数据</li>
<li>创建匿名类型: new + object初始化器，并指定属性及其值</li>
<li>使用var关键字来引用匿名类，因为匿名类型没有名字</li>
<li>匿名类属性的名称可以通过本身就是标识符/以标识符结尾的表达式推断出来</li>
<li>在同一个assembly下声明的两个匿名类实例，如果它们的元素名和类型都完全一致，那么它们的基础类型(underlying type)就是一样的</li>
<li>Equals方法被重写来进行相等性的比较</li>
<li>可以创建匿名类型数组</li>
<li>方法不可以返回匿名类型的对象，必须使用dynamic或者object, 调用时依赖于动态绑定，并且会损失静态类型的安全性。</li>
<li>匿名类型主要用来写LINQ查询</li>
</ul>

        <h3 id="元组（Tuple）"   >
          <a href="#元组（Tuple）" class="heading-link"><i class="fas fa-link"></i></a>元组（Tuple）</h3>
      <ul>
<li>Tuple提供了简单的方式来存储一组数据</li>
<li>使用Tuple的主要目的是从方法安全的返回多个值，而且无需使用out参数</li>
<li>C# 7的Tuple主要是依赖于一组支撑它的struct,叫做System.ValueTuple&lt;&gt;</li>
</ul>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var bob&#x3D; (&quot;Bob&quot;, 23);: &#x2F;&#x2F; Allow compiler to infer the element types</span><br><span class="line">Console. WriteI ine (bob.Item1): &#x2F;&#x2F; Bob</span><br><span class="line">Console.WriteL ine (bob.Item2); &#x2F;&#x2F; 23</span><br></pre></td></tr></table></div></figure>

<p>和匿名类型不同，可以将每一个元素的类型列在括号中，来显式指定元组的类型。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(string,int)bob &#x3D; (&quot;Bob&quot;,23);</span><br></pre></td></tr></table></div></figure>


        <h4 id="元组元素命名"   >
          <a href="#元组元素命名" class="heading-link"><i class="fas fa-link"></i></a>元组元素命名</h4>
      <p>当创建元组字面量时，可以为元组的元素起一些有意义的名字：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var tuple &#x3D; (Name:&quot;Bob&quot;,Age:23);</span><br></pre></td></tr></table></div></figure>

<p>也可以在指定元组类型时进行命名：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static (string Name,int Age) GetPerson() &#x3D;&gt;(&quot;Bob&quot;,23);</span><br></pre></td></tr></table></div></figure>


        <h4 id="类型擦除"   >
          <a href="#类型擦除" class="heading-link"><i class="fas fa-link"></i></a>类型擦除</h4>
      <p>C#使用了一组现存的泛型struct来处理Tuple</p>
<ul>
<li>public struct ValueTuple&lt;T1&gt;</li>
<li>public struct ValueTuple&lt;T1,T2&gt;</li>
<li>public struct ValueTuple&lt;T1,T2,T3&gt;</li>
<li>…</li>
<li>每个ValueTuple&lt;&gt;struct都有Item1，Item2…等字段</li>
</ul>
<p>因此，(string, int)是ValueTuple&lt;string, int&gt;的别名。同时，这意味着命名的元组元素并没有底层类型的命名属性的支撑。这些名字仅仅存在于源代码和编译器的想象”中。在运行时，这些名字大多会消失。当我们反编译引用命名元素的元组时，可以看到程序仅仅引用了Item1、Item2这样的字段。若将元组变量赋值给一个obect对象并在调试器 下观察(或者在LINQPad下输出)，就可以发现元素的名字完全消失了。因此，在绝大多数情况下，都不能用反射(reflection) 的方式确定元组在运行时的命名。</p>

        <h4 id="ValueTuple-Create"   >
          <a href="#ValueTuple-Create" class="heading-link"><i class="fas fa-link"></i></a>ValueTuple.Create</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ValueTuple&lt;string int&gt; bob1 &#x3D; ValueTuple.Create(&quot;Bob&quot;, 23):</span><br><span class="line">(string.int)bob2 &#x3D; ValueTuple.Create (&quot;Bob&quot;: 23);</span><br></pre></td></tr></table></div></figure>


        <h4 id="元组的解构"   >
          <a href="#元组的解构" class="heading-link"><i class="fas fa-link"></i></a>元组的解构</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var bob &#x3D; (&quot;Bob&quot;,23);</span><br><span class="line">(string name,int age) &#x3D; bob;</span><br><span class="line">Console.WriteLine(name); &#x2F;&#x2F; Bob</span><br><span class="line">Console.WriteLine(age); &#x2F;&#x2F; 23</span><br></pre></td></tr></table></div></figure>


        <h3 id="特性（Attribute"   >
          <a href="#特性（Attribute" class="heading-link"><i class="fas fa-link"></i></a>特性（Attribute)</h3>
      <ul>
<li>Attribute是一种扩展机制，它可以为代码元素添加自定义的信息<ul>
<li>一Assembly, 类型、成员、返回值、参数、泛型参数</li>
</ul>
</li>
<li>一个很好的应用场景就是序列化<ul>
<li>把任意一个对象转化为特定格式/从特定格式转化过来</li>
</ul>
</li>
</ul>

        <h4 id="特性类"   >
          <a href="#特性类" class="heading-link"><i class="fas fa-link"></i></a>特性类</h4>
      <p>一个Attribute是通过一个（直接或间接）继承了System.Attribute的类来定义的</p>
<p>把Attribute应用于代码元素</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ObsoleteAttribute] &#x2F;&#x2F; 可省略为[Obsolete]</span><br><span class="line">public class Foo&#123;...&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="命名和位置Attribute参数"   >
          <a href="#命名和位置Attribute参数" class="heading-link"><i class="fas fa-link"></i></a>命名和位置Attribute参数</h4>
      <p>Attribute 可以有参数</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[XmlElement ( &quot;Customer&quot;，Namespace&#x3D;&quot;http: &#x2F;&#x2F;oreilly. com&quot;)]</span><br><span class="line">public class CustomerEntity &#123; ... &#125;</span><br></pre></td></tr></table></div></figure>

<p>Attribute的参数可以分为两类: 位置的和命名的<br>位置参数对应Attribute类型的公共构造函数的参数<br>命名参数对应Attribute类型的公共字段或公共属性<br>当指定Attribute的时候， 必须包含与Attribute相应构造函数所对应的位置参数，而命名参数是可选的。</p>

        <h3 id="预处理指令（详见官方文档）"   >
          <a href="#预处理指令（详见官方文档）" class="heading-link"><i class="fas fa-link"></i></a>预处理指令（详见官方文档）</h3>
      <p>预处理器指令向编译器提供有关代码区域的附加信息。<br>最常见的预处理器指令是条件指令，它提供了从编译中包含或排除代码区域的方法。<br>预处理器符号可以在源文件中定义，也可以通过设定/define:symbol命令行选项进行定义。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define DEBUG</span><br><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    void Foo0()</span><br><span class="line">    &#123;</span><br><span class="line">        #if DEBUG</span><br><span class="line">        Console.WriteLine(&quot;Testing:x&#x3D; &#123;0&#125; &quot;, x);</span><br><span class="line">        #endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/07/05/Csharp/">C#初阶</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-07-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-07-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>[TOC]</p>

        <h2 id="编译"   >
          <a href="#编译" class="heading-link"><i class="fas fa-link"></i></a>编译</h2>
      <ul>
<li>C#编译器是把.cs结尾的源码文件编译成Assembly</li>
<li>Assembly是.NET Core里的包装和部署的单元</li>
<li>Assembly可以是应用程序，也可以是库<ul>
<li>.exe</li>
<li>.dll</li>
</ul>
</li>
</ul></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/07/05/Csharp/"><span class="post-readmore__text">Read More</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/">设计模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-07-12</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="设计模式"   >
          <a href="#设计模式" class="heading-link"><i class="fas fa-link"></i></a>设计模式</h1>
      
        <h4 id="单例模式"   >
          <a href="#单例模式" class="heading-link"><i class="fas fa-link"></i></a>单例模式</h4>
      <p>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。类的构造方法一定不能是public的 ，只能是private。这个实例是当前类的类成员变量，静态变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPattern</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton; <span class="comment">//唯一类变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">//构造方法私有</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/"><span class="post-readmore__text">Read More</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/28/vscode%E9%85%8D%E7%BD%AE/">vscode配置</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-07-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="VSCode配置"   >
          <a href="#VSCode配置" class="heading-link"><i class="fas fa-link"></i></a>VSCode配置</h1>
      
        <h3 id="更换主题"   >
          <a href="#更换主题" class="heading-link"><i class="fas fa-link"></i></a>更换主题</h3>
      <p>ctrl+shift+p 后输入Preferences Color Theme进行选择</p>

        <h4 id="图标主题"   >
          <a href="#图标主题" class="heading-link"><i class="fas fa-link"></i></a>图标主题</h4>
      <p>ctrl+shift+p 后输入Preferences File Icon Theme进行选择</p></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/06/28/vscode%E9%85%8D%E7%BD%AE/"><span class="post-readmore__text">Read More</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/28/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">Java学习路线</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-29</span></span></div></header><div class="post-body"><div class="post-excerpt"><hr>

        <h2 id="title：Java学习路线"   >
          <a href="#title：Java学习路线" class="heading-link"><i class="fas fa-link"></i></a>title：Java学习路线</h2>
      <hr>
<p>测试字段</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/28/hello-world/">Hello World</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-07-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Welcome to <span class="exturl"><a class="exturl__link"   href="https://hexo.io/"  target="_blank" rel="noopener">Hexo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>! This is your very first post. Check <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/"  target="_blank" rel="noopener">documentation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/troubleshooting.html"  target="_blank" rel="noopener">troubleshooting</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> or you can ask me on <span class="exturl"><a class="exturl__link"   href="https://github.com/hexojs/hexo/issues"  target="_blank" rel="noopener">GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>

        <h2 id="Quick-Start"   >
          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a>Quick Start</h2>
      
        <h3 id="Create-a-new-post"   >
          <a href="#Create-a-new-post" class="heading-link"><i class="fas fa-link"></i></a>Create a new post</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/writing.html"  target="_blank" rel="noopener">Writing</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Run-server"   >
          <a href="#Run-server" class="heading-link"><i class="fas fa-link"></i></a>Run server</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/server.html"  target="_blank" rel="noopener">Server</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Generate-static-files"   >
          <a href="#Generate-static-files" class="heading-link"><i class="fas fa-link"></i></a>Generate static files</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/generating.html"  target="_blank" rel="noopener">Generating</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Deploy-to-remote-sites"   >
          <a href="#Deploy-to-remote-sites" class="heading-link"><i class="fas fa-link"></i></a>Deploy to remote sites</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/one-command-deployment.html"  target="_blank" rel="noopener">Deployment</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/L.png" alt="avatar"></div><p class="sidebar-ov-author__text">Szwyz's Blog</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/Sz-wyz" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="1830413177@qq.com" target="_blank" rel="noopener" data-popover="social.email" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">6</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Categories</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-bolt"></i></span><span>Lhn</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v4.2.1</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>